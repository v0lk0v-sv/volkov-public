import {
  clsx
} from "./chunk-UVUMECS7.js";
import {
  require_jsx_runtime
} from "./chunk-BX4QH3UP.js";
import {
  useStore
} from "./chunk-S75IEP5I.js";
import "./chunk-WZKXN3TW.js";
import {
  require_react
} from "./chunk-YZZKIYU7.js";
import {
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/@av/timeline/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var React = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@av/timeline/node_modules/nanostores/action/index.js
var lastAction = Symbol();
var actionId = Symbol();

// node_modules/@av/timeline/node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/@av/timeline/node_modules/nanostores/atom/index.js
var listenerQueue = [];
var atom = (initialValue, level) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    l: level || 0,
    lc: 0,
    listen(listener, listenerLevel) {
      $atom.lc = listeners.push(listener, listenerLevel || $atom.l) / 2;
      return () => {
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 2);
          if (!--$atom.lc)
            $atom.off();
        }
      };
    },
    notify(changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let i = 0; i < listeners.length; i += 2) {
        listenerQueue.push(
          listeners[i],
          listeners[i + 1],
          $atom.value,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (let i = 0; i < listenerQueue.length; i += 4) {
          let skip;
          for (let j = i + 1; !skip && (j += 4) < listenerQueue.length; ) {
            if (listenerQueue[j] < listenerQueue[i + 1]) {
              skip = listenerQueue.push(
                listenerQueue[i],
                listenerQueue[i + 1],
                listenerQueue[i + 2],
                listenerQueue[i + 3]
              );
            }
          }
          if (!skip) {
            listenerQueue[i](listenerQueue[i + 2], listenerQueue[i + 3]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    off() {
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    set(data) {
      if ($atom.value !== data) {
        $atom.value = data;
        $atom.notify();
      }
    },
    subscribe(listener, listenerLevel) {
      let unbind = $atom.listen(listener, listenerLevel);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/@av/timeline/node_modules/nanostores/lifecycle/index.js
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event2, l) => (l(event2), event2), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy)
      $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT])
            destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean];
      $store[clean] = () => {
        for (let destroy of $store.events[UNMOUNT])
          destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/@av/timeline/node_modules/nanostores/computed/index.js
var computed = (stores, cb) => {
  if (!Array.isArray(stores))
    stores = [stores];
  let diamondArgs;
  let run = () => {
    let args = stores.map(($store) => $store.get());
    if (diamondArgs === void 0 || args.some((arg, i) => arg !== diamondArgs[i])) {
      diamondArgs = args;
      $computed.set(cb(...args));
    }
  };
  let $computed = atom(void 0, Math.max(...stores.map((s) => s.l)) + 1);
  onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run, $computed.l));
    run();
    return () => {
      for (let unbind of unbinds)
        unbind();
    };
  });
  return $computed;
};

// node_modules/@av/timeline/node_modules/nanostores/map/index.js
var map = (value2 = {}) => {
  let $map = atom(value2);
  $map.setKey = function(key, newValue) {
    if (typeof newValue === "undefined") {
      if (key in $map.value) {
        $map.value = { ...$map.value };
        delete $map.value[key];
        $map.notify(key);
      }
    } else if ($map.value[key] !== newValue) {
      $map.value = {
        ...$map.value,
        [key]: newValue
      };
      $map.notify(key);
    }
  };
  return $map;
};

// node_modules/@av/timeline/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var activeEvent = "_activeEvent_15yh3_1";
var visible$1 = "_visible_15yh3_13";
var styles$a = {
  activeEvent,
  visible: visible$1
};
function ActiveEvent({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const [lastActiveEvent, setLastActiveEvent] = (0, import_react.useState)(null);
  const { $settings, $activeEvent } = timelineStore;
  const { $timelineSize } = timelineStore.viewState;
  const { renderActiveEvent: renderActiveEvent2 } = useStore($settings);
  (0, import_react.useEffect)(() => {
    if (!renderActiveEvent2) {
      return;
    }
    return $activeEvent.subscribe((activeEvent2) => {
      if (activeEvent2) {
        setLastActiveEvent(activeEvent2);
      }
      const node = ref.current;
      if (!node) {
        return;
      }
      node.classList.toggle(styles$a.visible, Boolean(activeEvent2));
    });
  }, [$activeEvent, renderActiveEvent2]);
  (0, import_react.useEffect)(() => {
    if (!renderActiveEvent2) {
      return;
    }
    return $timelineSize.subscribe(({ activeEventPanelWidth }) => {
      if (!ref.current) {
        return;
      }
      ref.current.style.width = `${activeEventPanelWidth}px`;
    });
  }, [$timelineSize, renderActiveEvent2]);
  if (!renderActiveEvent2) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$a.activeEvent, ref, children: lastActiveEvent && renderActiveEvent2(lastActiveEvent) });
}
var EnhancedActiveEvent = (0, import_react.memo)(ActiveEvent);
var currentTime = "_currentTime_cmdjp_1";
var point = "_point_cmdjp_10";
var styles$9 = {
  currentTime,
  point
};
function CurrentTime({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const visibleRef = (0, import_react.useRef)(false);
  const { $currentTime, $settings } = timelineStore;
  const { $timeState, $viewRangeTime, $timelineSize } = timelineStore.viewState;
  const { showCurrentTime } = useStore($settings);
  (0, import_react.useEffect)(() => {
    if (!showCurrentTime) {
      visibleRef.current = false;
      return;
    }
    const $data = computed(
      [$currentTime, $timeState, $viewRangeTime, $timelineSize],
      (currentTime2, timeState, viewRangeTime, timelineSize) => ({
        currentTime: currentTime2,
        timeState,
        viewRangeTime,
        timelineSize
      })
    );
    const unsubscribe = $data.subscribe(({ currentTime: currentTime2, timeState, viewRangeTime, timelineSize }) => {
      const node = ref.current;
      if (!node) {
        return;
      }
      const [start, end] = viewRangeTime;
      if (currentTime2 < start || currentTime2 > end) {
        if (visibleRef.current) {
          visibleRef.current = false;
          node.style.display = "none";
        }
        return;
      }
      if (!visibleRef.current) {
        visibleRef.current = true;
        node.style.display = "block";
      }
      const left = Math.round((currentTime2 - timeState.start) / timeState.scale - 1);
      const top = timelineSize.headerHeight;
      node.style.left = `${left}px`;
      node.style.top = `${top}px`;
    });
    return () => {
      unsubscribe();
      $data.off();
    };
  }, [$currentTime, $timeState, $viewRangeTime, $timelineSize, showCurrentTime]);
  if (!showCurrentTime) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$9.currentTime, ref, children: (0, import_jsx_runtime.jsx)("div", { className: styles$9.point }) });
}
var EnhancedCurrentTime = (0, import_react.memo)(CurrentTime);
var SECOND_MS = 1e3;
var MINUTE_MS = SECOND_MS * 60;
var HOUR_MS = MINUTE_MS * 60;
var DAY_MS = HOUR_MS * 24;
var GRID_STEP_SIZES = [
  SECOND_MS * 10,
  SECOND_MS * 20,
  SECOND_MS * 30,
  MINUTE_MS,
  MINUTE_MS * 2,
  MINUTE_MS * 3,
  MINUTE_MS * 5,
  MINUTE_MS * 10,
  MINUTE_MS * 20,
  MINUTE_MS * 30,
  HOUR_MS,
  HOUR_MS * 2,
  HOUR_MS * 4,
  HOUR_MS * 8,
  HOUR_MS * 12,
  DAY_MS
];
var DEFAULT_HEADER_HEIGHT = 44;
var MIN_GRID_WIDTH = 60;
var DEFAULT_SCALE = HOUR_MS * 4 / 70;
var MAX_SCALE = GRID_STEP_SIZES[GRID_STEP_SIZES.length - 1] / 60;
var MIN_SCALE = GRID_STEP_SIZES[0] / 100;
var DEFAULT_DATA_VIEW_PADDING = 8;
var DEFAULT_EVENT_LINE_HEIGHT = 8;
var DEFAULT_EVENT_LINE_MARGIN = 3;
var DEFAULT_ROW_PADDING = 10;
var DEFAULT_EVENT_CONTENT_MIN_WIDTH = 10;
var SIDEBAR_LOADING_HEIGHT = 32;
var DEFAULT_EVENTS_LOAD_STEP_SIZE = DAY_MS;
var MAX_PARALLEL_EVENTS_REQUEST = 5;
var EVENT_POPUP_OFFSET = 6;
var SUPPORTED_TIME_ZONES = Intl.supportedValuesOf("timeZone");
var CURRENT_TIME_ZONE = Intl.DateTimeFormat().resolvedOptions().timeZone;
var DEVICE_PIXEL_RATIO = window.devicePixelRatio;
var lastGridStepSize = GRID_STEP_SIZES[GRID_STEP_SIZES.length - 1];
function getGridStepSize(scale) {
  for (let i = 0; i < GRID_STEP_SIZES.length; i++) {
    const step = GRID_STEP_SIZES[i];
    const width = step / scale;
    if (width >= MIN_GRID_WIDTH) {
      return step;
    }
  }
  return lastGridStepSize;
}
function fitTimeToStepSize(time2, stepSize, timezoneOffset) {
  const sameUTCTime = time2 - timezoneOffset;
  const clippedUTCTime = Math.floor(sameUTCTime / stepSize) * stepSize;
  const timeDiff = sameUTCTime - clippedUTCTime;
  const newTime = time2 - timeDiff;
  return newTime;
}
function stringifyTime(time2, gridStepSize, viewTimeZone) {
  return new Date(time2).toLocaleString("en-US", {
    hourCycle: "h23",
    hour: "numeric",
    minute: "numeric",
    second: gridStepSize < MINUTE_MS ? "numeric" : void 0,
    timeZone: viewTimeZone.name
  });
}
function stringifyDay(time2, viewTimeZone) {
  return new Date(time2).toLocaleString("en-US", {
    day: "numeric",
    month: "short",
    timeZone: viewTimeZone.name
  });
}
function onWheel($mouseCoords, listener) {
  const eventListener = (event2) => {
    if (event2.metaKey || event2.ctrlKey) {
      const { left } = $mouseCoords.get();
      const containerOffset = left;
      const delta = event2.deltaY;
      listener(containerOffset, delta);
      event2.preventDefault();
    }
  };
  window.addEventListener("wheel", eventListener, { passive: false });
  return () => window.removeEventListener("wheel", eventListener);
}
function pluralize(value2, strOne, strMany) {
  if (value2 % 10 === 1) {
    return strOne;
  }
  return strMany;
}
function stringifyGridStepSize(gridStepSize) {
  if (gridStepSize < MINUTE_MS) {
    const value22 = Math.round(gridStepSize / SECOND_MS);
    return `${value22} ${pluralize(value22, "sec", "sec")}`;
  }
  if (gridStepSize < HOUR_MS) {
    const value22 = Math.round(gridStepSize / MINUTE_MS);
    return `${value22} ${pluralize(value22, "min", "min")}`;
  }
  if (gridStepSize < DAY_MS) {
    const value22 = Math.round(gridStepSize / HOUR_MS);
    return `${value22} ${pluralize(value22, "hr", "hrs")}`;
  }
  const value2 = Math.round(gridStepSize / DAY_MS);
  return `${value2} ${pluralize(value2, "day", "days")}`;
}
function updateTimeState(timeState, delta, containerOffset) {
  const { scale: currentScale, start: currentStart } = timeState;
  let newScale = currentScale * 60 / (60 - delta / 2.5);
  if (newScale > MAX_SCALE) {
    newScale = MAX_SCALE;
  } else if (newScale < MIN_SCALE) {
    newScale = MIN_SCALE;
  }
  const newStart = Math.round(currentStart + containerOffset * currentScale - containerOffset * newScale);
  return {
    scale: newScale,
    start: newStart
  };
}
var TARGET_FRAME_STEP_SIZE = 1e3 / 60;
var SLOW_DOWN_FACTOR = 10;
var nextFramePlanned = false;
var animationFrames = [];
function requestFrame(handler) {
  animationFrames.push(handler);
  if (nextFramePlanned) {
    return;
  }
  nextFramePlanned = true;
  requestAnimationFrame((timestamp) => {
    const currentFrames = animationFrames;
    animationFrames = [];
    nextFramePlanned = false;
    for (let i = 0; i < currentFrames.length; i++) {
      const handler2 = currentFrames[i];
      handler2(timestamp);
    }
  });
}
function initAnimationController(defaultValue, setValue, onAnimationStop) {
  let targetValue = defaultValue;
  let activeValue = defaultValue;
  let animationSpeed = 0;
  let lastFrameTime = null;
  let distanceFactor = 0;
  let treshold = 0;
  let active = false;
  let destroyed = false;
  const updateValue = (value2) => {
    activeValue = value2;
    setValue(value2);
  };
  const finishAnimation = () => {
    updateValue(targetValue);
    lastFrameTime = null;
    animationSpeed = 0;
    active = false;
    if (onAnimationStop) {
      onAnimationStop();
    }
  };
  const set = (value2) => {
    if (value2 !== activeValue) {
      targetValue = value2;
      updateValue(value2);
    }
  };
  const animate = (timestamp) => {
    if (destroyed) {
      return;
    }
    const diff = targetValue - activeValue;
    const absDiff = Math.abs(diff);
    if (absDiff <= treshold) {
      finishAnimation();
      return;
    }
    const timestampDiff = lastFrameTime ? timestamp - lastFrameTime : TARGET_FRAME_STEP_SIZE;
    const timeScale = timestampDiff / TARGET_FRAME_STEP_SIZE;
    const targetHits = (absDiff / distanceFactor + SLOW_DOWN_FACTOR) / 2;
    const targetSpeed = diff / targetHits;
    const newAnimationSpeed = (animationSpeed + targetSpeed) / 2;
    const shift = (newAnimationSpeed + newAnimationSpeed * timeScale) / 2;
    if (Math.abs(shift) >= absDiff) {
      finishAnimation();
      return;
    }
    const newValue = activeValue + shift;
    lastFrameTime = timestamp;
    animationSpeed = newAnimationSpeed;
    updateValue(newValue);
    requestFrame(animate);
  };
  const move = (value2, newDistanceFactor) => {
    if (targetValue === value2) {
      return;
    }
    targetValue = value2;
    distanceFactor = newDistanceFactor;
    treshold = newDistanceFactor / 500;
    if (!active) {
      active = true;
      requestFrame(animate);
    }
  };
  const reset = () => {
    destroyed = true;
  };
  return { move, set, reset };
}
function parseDateComponents(date, timeZone) {
  const str = date.toLocaleString("en-US", {
    hourCycle: "h23",
    timeZone,
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric"
  });
  const match = str.match(/^(\d+)\/(\d+)\/(\d+),\s(\d+):(\d+)$/);
  if (!match) {
    return null;
  }
  const [, month, day, year, hour, minute] = match;
  return {
    year: Number(year),
    month: Number(month) - 1,
    day: Number(day),
    hour: Number(hour),
    minute: Number(minute)
  };
}
function getComponentsTimestamp(components) {
  const { year, month, day, hour, minute } = components;
  return Date.UTC(year, month, day, hour, minute);
}
function getTimezoneOffset(time2, timeZone) {
  const date = time2 ? new Date(time2) : /* @__PURE__ */ new Date();
  const currentTimezoneOffset = date.getTimezoneOffset() * MINUTE_MS;
  if (!timeZone) {
    return currentTimezoneOffset;
  }
  if (!SUPPORTED_TIME_ZONES.includes(timeZone)) {
    console.error(`Unsupported time zone ${timeZone}, local time zone will be used: ${CURRENT_TIME_ZONE}`);
    return currentTimezoneOffset;
  }
  const tzComponents = parseDateComponents(date, timeZone);
  const utcComponents = parseDateComponents(date, "UTC");
  if (!tzComponents || !utcComponents) {
    return currentTimezoneOffset;
  }
  const timezoneOffset = getComponentsTimestamp(utcComponents) - getComponentsTimestamp(tzComponents);
  return timezoneOffset;
}
var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function stringifyDateRange(start, end, viewTimeZone) {
  const startComponents = parseDateComponents(new Date(start), viewTimeZone.name);
  const endComponents = parseDateComponents(new Date(end), viewTimeZone.name);
  if (!startComponents || !endComponents) {
    return "";
  }
  const { month: startMonth, day: startDay } = startComponents;
  const { month: endMonth, day: endDay } = endComponents;
  if (startMonth === endMonth) {
    if (startDay === endDay) {
      return `${months[startMonth]} ${startDay}`;
    }
    return `${months[startMonth]} ${startDay} – ${endDay}`;
  }
  return `${months[startMonth]} ${startDay} – ${months[endMonth]} ${endDay}`;
}
function getEventsLoadSteps(range, loadStepSize, timezoneOffset) {
  const [start, end] = range;
  let eventsLoadStep = fitTimeToStepSize(start, loadStepSize, timezoneOffset);
  const eventsLoadSteps = [];
  while (eventsLoadStep < end) {
    eventsLoadSteps.push(eventsLoadStep);
    eventsLoadStep += loadStepSize;
  }
  return eventsLoadSteps;
}
var EventsStorage = class {
  constructor(dataTZOffset, eventsLoadStepSize) {
    __publicField(this, "events", {});
    __publicField(this, "subscribers", /* @__PURE__ */ new Map());
    __publicField(this, "dataTZOffset");
    __publicField(this, "eventsLoadStepSize");
    this.dataTZOffset = dataTZOffset;
    this.eventsLoadStepSize = eventsLoadStepSize;
  }
  subscribe(rowId, listener) {
    let subscribers = this.subscribers.get(rowId);
    if (!subscribers) {
      subscribers = /* @__PURE__ */ new Set();
      this.subscribers.set(rowId, subscribers);
    }
    subscribers.add(listener);
    return () => subscribers == null ? void 0 : subscribers.delete(listener);
  }
  unsubscribe(rowId, listener) {
    const subscribers = this.subscribers.get(rowId);
    if (subscribers) {
      subscribers.delete(listener);
    }
  }
  getEvents(rowId, range) {
    const rowEvents = this.events[rowId];
    if (!rowEvents) {
      return [];
    }
    const eventsLoadSteps = getEventsLoadSteps(range, this.eventsLoadStepSize, this.dataTZOffset);
    const [from, to] = range;
    const outOfLoadStepSet = /* @__PURE__ */ new Set();
    const events = [];
    for (let i = 0; i < eventsLoadSteps.length; i++) {
      const loadStepStart = eventsLoadSteps[i];
      const loadStepEnd = loadStepStart + this.eventsLoadStepSize;
      const loadStepEvents = rowEvents[loadStepStart];
      if (loadStepEvents) {
        for (let j = 0; j < loadStepEvents.length; j++) {
          const event2 = loadStepEvents[j];
          const isInRange = event2.start < to && event2.end > from;
          if (!isInRange) {
            continue;
          }
          const isOutOfLoadStep = event2.start < loadStepStart || event2.end > loadStepEnd;
          if (isOutOfLoadStep) {
            if (outOfLoadStepSet.has(event2.id)) {
              continue;
            }
            outOfLoadStepSet.add(event2.id);
          }
          events.push(event2);
        }
      }
    }
    return events;
  }
  set(rowId, from, events) {
    let rowEvents = this.events[rowId];
    if (!rowEvents) {
      rowEvents = {};
      this.events[rowId] = rowEvents;
    }
    rowEvents[from] = events;
    const subscribers = this.subscribers.get(rowId);
    if (subscribers) {
      subscribers.forEach((listener) => listener());
    }
  }
  getChunk(rowId, from) {
    const rowEvents = this.events[rowId];
    if (rowEvents) {
      return rowEvents[from] || null;
    }
    return null;
  }
  reset() {
    this.subscribers = /* @__PURE__ */ new Map();
    this.events = {};
  }
};
function stringifyTimeUnit(value2) {
  return String(value2).padStart(2, "0");
}
function stringifyTimeRange(start, end) {
  const startDate = new Date(start);
  const startHour = stringifyTimeUnit(startDate.getHours());
  const startMinute = stringifyTimeUnit(startDate.getMinutes());
  const startSecond = stringifyTimeUnit(startDate.getSeconds());
  if (start === end) {
    return `${startHour}:${startMinute}:${startSecond}`;
  }
  const endDate = new Date(end);
  const endHour = stringifyTimeUnit(endDate.getHours());
  const endMinute = stringifyTimeUnit(endDate.getMinutes());
  const endSecond = stringifyTimeUnit(endDate.getSeconds());
  if (end - start > MINUTE_MS * 10) {
    return `${startHour}:${startMinute} – ${endHour}:${endMinute}`;
  }
  return `${startHour}:${startMinute}:${startSecond} – ${endHour}:${endMinute}:${endSecond}`;
}
function getUserTimeZoneOffset() {
  return (/* @__PURE__ */ new Date()).getTimezoneOffset() * MINUTE_MS;
}
function stringifyTimezoneOffset(timezoneOffset) {
  if (timezoneOffset === 0) {
    return "GMT";
  }
  const sign = timezoneOffset > 0 ? "+" : "-";
  const offset = Math.abs(timezoneOffset);
  const hours = Math.floor(offset / HOUR_MS);
  const minutes = Math.floor((offset - hours * HOUR_MS) / MINUTE_MS);
  return `GMT${sign}${stringifyTimeUnit(hours)}:${stringifyTimeUnit(minutes)}`;
}
function debouncedStore($store, timeout) {
  const $debounced = atom($store.get());
  let timer = null;
  const unlisten = $store.listen((value2) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      $debounced.set(value2);
      timer = null;
    }, timeout);
  });
  const reset = () => {
    unlisten();
    if (timer) {
      clearTimeout(timer);
    }
  };
  return [$debounced, reset];
}
function usePersistentCallback(func) {
  const ref = (0, import_react.useRef)(func || null);
  ref.current = func || null;
  const callback = (0, import_react.useCallback)((...args) => {
    if (ref.current) {
      return ref.current(...args);
    }
  }, []);
  return callback;
}
function stringifyTimeDuration(diff) {
  if (diff === 0) {
    return "";
  }
  const hoursFloor = Math.floor(diff / HOUR_MS);
  const hoursRound = Math.round(diff / HOUR_MS);
  if (hoursFloor > 20) {
    return `${hoursRound} ${pluralize(hoursRound, "hr", "hrs")}`;
  }
  const minutesFloor = Math.floor((diff - hoursFloor * HOUR_MS) / MINUTE_MS);
  const minutesRound = Math.round((diff - hoursFloor * HOUR_MS) / MINUTE_MS);
  if (hoursFloor > 0) {
    if (minutesRound > 0) {
      return `${hoursFloor} ${pluralize(hoursFloor, "hr", "hrs")} ${minutesRound} min`;
    }
    return `${hoursRound} ${pluralize(hoursRound, "hr", "hrs")}`;
  }
  if (minutesFloor > 20) {
    return `${minutesRound} min`;
  }
  const secondsRound = Math.round((diff - hoursFloor * HOUR_MS - minutesFloor * MINUTE_MS) / SECOND_MS);
  if (minutesFloor > 0) {
    if (secondsRound > 0) {
      return `${minutesFloor} min ${secondsRound} sec`;
    }
    return `${minutesRound} min`;
  }
  return `${secondsRound} sec`;
}
function getNestedRowsIds(rowsIds, rowsMap, rowsExpanded) {
  const list = [];
  for (let i = 0; i < rowsIds.length; i++) {
    const rowId = rowsIds[i];
    list.push(rowId);
    const { children } = rowsMap[rowId];
    const expanded2 = !rowsExpanded || rowsExpanded[rowId];
    if (children && expanded2) {
      const childIds = children.map(({ id }) => id);
      list.push(...getNestedRowsIds(childIds, rowsMap, rowsExpanded));
    }
  }
  return list;
}
function getNestedCoolapsedRowsIds(rowId, rowsMap, rowsExpanded, parentCollapsed) {
  const rowsIds = [rowId];
  const expanded2 = rowsExpanded[rowId];
  const { children } = rowsMap[rowId];
  if ((!expanded2 || parentCollapsed) && children) {
    for (let i = 0; i < children.length; i++) {
      const childRow = children[i];
      rowsIds.push(...getNestedCoolapsedRowsIds(childRow.id, rowsMap, rowsExpanded, true));
    }
  }
  return rowsIds;
}
function joinSortedTwoEvents(events1, events2) {
  const events = [];
  let index1 = 0;
  let index2 = 0;
  const length1 = events1.length;
  const length2 = events2.length;
  while (index1 < length1 && index2 < length2) {
    const event1 = events1[index1];
    const event2 = events2[index2];
    if (event1.start < event2.start) {
      events.push(event1);
      index1 += 1;
    } else {
      events.push(event2);
      index2 += 1;
    }
  }
  if (index1 < length1) {
    events.push(...events1.slice(index1));
  }
  if (index2 < length2) {
    events.push(...events2.slice(index2));
  }
  return events;
}
function joinSortedEvents(eventsLists) {
  if (eventsLists.length === 0) {
    return [];
  }
  if (eventsLists.length === 1) {
    return eventsLists[0];
  }
  const [first, ...rest] = eventsLists;
  return joinSortedTwoEvents(first, joinSortedEvents(rest));
}
function getRowHeightWithChildren(rowId, rowsHeight, rowsMap) {
  let height = rowsHeight[rowId];
  const { children } = rowsMap[rowId];
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const childItem = children[i];
      height += getRowHeightWithChildren(childItem.id, rowsHeight, rowsMap);
    }
  }
  return height;
}
function findEventIndex(events, event2) {
  let startIndex = 0;
  let endIndex = events.length - 1;
  let middleIndex = Math.floor(events.length / 2);
  while (startIndex < endIndex) {
    const middleEvent = events[middleIndex];
    if (middleEvent.id === event2.id) {
      return middleIndex;
    }
    if (middleEvent.start === event2.start) {
      let index = middleIndex - 1;
      while (index > 0) {
        const indexEvent = events[index];
        if (indexEvent.id === event2.id) {
          return index;
        }
        if (indexEvent.start !== event2.start) {
          break;
        }
        index--;
      }
      index = middleIndex + 1;
      while (index < events.length) {
        const indexEvent = events[index];
        if (indexEvent.id === event2.id) {
          return index;
        }
        if (indexEvent.start !== event2.start) {
          break;
        }
        index++;
      }
      return null;
    }
    if (middleEvent.start < event2.start) {
      startIndex = middleIndex;
    } else {
      endIndex = middleIndex;
    }
    middleIndex = Math.floor((endIndex + startIndex) / 2);
    if (middleIndex === startIndex || middleIndex === endIndex) {
      const startEvent = events[startIndex];
      if (startEvent.id === event2.id) {
        return startIndex;
      }
      const endEvent = events[endIndex];
      if (endEvent.id === event2.id) {
        return endIndex;
      }
      break;
    }
  }
  return null;
}
function getEventsDiff(oldEvents, newEvents) {
  const oldLength = oldEvents.length;
  const newLength = newEvents.length;
  if (oldLength < 4 || newLength < 4) {
    return null;
  }
  const newMiddleIndex = Math.floor(newLength / 2);
  const oldMiddleIndex = findEventIndex(oldEvents, newEvents[newMiddleIndex]);
  if (!oldMiddleIndex) {
    return null;
  }
  let newIndex = newMiddleIndex - 1;
  let oldIndex = oldMiddleIndex - 1;
  let newMatchStartIndex = null;
  let oldMatchStartIndex = null;
  while (newIndex >= 0 && oldIndex >= 0) {
    const newEvent = newEvents[newIndex];
    const oldEvent = oldEvents[oldIndex];
    if (newEvent.id !== oldEvent.id) {
      newMatchStartIndex = newIndex + 1;
      oldMatchStartIndex = oldIndex + 1;
      break;
    }
    newIndex--;
    oldIndex--;
  }
  if (newMatchStartIndex === null || oldMatchStartIndex === null) {
    newMatchStartIndex = newIndex + 1;
    oldMatchStartIndex = oldIndex + 1;
  }
  newIndex = newMiddleIndex + 1;
  oldIndex = oldMiddleIndex + 1;
  let newMatchEndIndex = null;
  let oldMatchEndIndex = null;
  while (newIndex < newLength && oldIndex < oldLength) {
    const newEvent = newEvents[newIndex];
    const oldEvent = oldEvents[oldIndex];
    if (newEvent.id !== oldEvent.id) {
      newMatchEndIndex = newIndex - 1;
      oldMatchEndIndex = oldIndex - 1;
      break;
    }
    newIndex++;
    oldIndex++;
  }
  if (newMatchEndIndex === null || oldMatchEndIndex === null) {
    newMatchEndIndex = newIndex - 1;
    oldMatchEndIndex = oldIndex - 1;
  }
  const removedStart = oldEvents.slice(0, oldMatchStartIndex);
  const addedStart = newEvents.slice(0, newMatchStartIndex);
  const removedEnd = oldEvents.slice(oldMatchEndIndex + 1);
  const addedEnd = newEvents.slice(newMatchEndIndex + 1);
  const totalChanged = removedStart.length + addedStart.length + removedEnd.length + addedEnd.length;
  if (totalChanged / newLength < 0.5) {
    return {
      addedEnd,
      addedStart,
      removedEnd,
      removedStart
    };
  }
  return null;
}
function createAtom(defaultValue) {
  const $atom = atom(defaultValue);
  const reset = () => {
    $atom.off();
  };
  return [$atom, reset];
}
function createMapStore(defaultValue) {
  const $atom = map(defaultValue);
  const reset = () => {
    $atom.off();
  };
  return [$atom, reset];
}
var activeDate = "_activeDate_ttdj9_1";
var value$1 = "_value_ttdj9_16";
var timezone = "_timezone_ttdj9_21";
var styles$8 = {
  activeDate,
  value: value$1,
  timezone
};
function ActiveDate({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const timeRef = (0, import_react.useRef)(null);
  const timezoneRef = (0, import_react.useRef)(null);
  const timeTextRef = (0, import_react.useRef)("");
  const timezoneTextRef = (0, import_react.useRef)("");
  const { $viewRangeTime, $timelineSize } = timelineStore.viewState;
  const { $viewTimeZone, $settings } = timelineStore;
  const { showTimezoneInfo } = useStore($settings);
  (0, import_react.useEffect)(() => {
    timeTextRef.current = "";
    timezoneTextRef.current = "";
    const $timeText = computed([$viewRangeTime, $viewTimeZone], (viewRangeTime, viewTimeZone) => {
      const [start, end] = viewRangeTime;
      return stringifyDateRange(start, end, viewTimeZone);
    });
    const unsubscribeTimeText = $timeText.subscribe((timeText) => {
      if (!timeRef.current) {
        return;
      }
      if (timeTextRef.current === timeText) {
        return;
      }
      timeTextRef.current = timeText;
      timeRef.current.innerHTML = "";
      timeRef.current.appendChild(document.createTextNode(timeText));
    });
    const unsubscribeTimeZone = $viewTimeZone.subscribe((viewTimeZone) => {
      if (!timezoneRef.current) {
        return;
      }
      const { name, offset } = viewTimeZone;
      let timezoneText = name;
      if (name === CURRENT_TIME_ZONE) {
        timezoneText = "";
      } else {
        const offsetStr = stringifyTimezoneOffset(offset);
        timezoneText = `${offsetStr} ${name}`;
      }
      if (timezoneTextRef.current === timezoneText) {
        return;
      }
      timezoneTextRef.current = timezoneText;
      timezoneRef.current.innerHTML = "";
      if (!timezoneText) {
        timezoneRef.current.style.display = "none";
      } else {
        timezoneRef.current.style.display = "block";
        timezoneRef.current.appendChild(document.createTextNode(timezoneText));
      }
    });
    const unsubscribeTimelineSize = $timelineSize.subscribe((timelineSize) => {
      if (!ref.current) {
        return;
      }
      const { sidebarWidth } = timelineSize;
      ref.current.style.width = `${sidebarWidth}px`;
    });
    return () => {
      unsubscribeTimeText();
      unsubscribeTimeZone();
      unsubscribeTimelineSize();
      $timeText.off();
    };
  }, [$viewRangeTime, $viewTimeZone, $timelineSize, showTimezoneInfo]);
  return (0, import_jsx_runtime.jsxs)("div", { className: styles$8.activeDate, ref, children: [
    (0, import_jsx_runtime.jsx)("div", { className: styles$8.value, ref: timeRef }),
    showTimezoneInfo && (0, import_jsx_runtime.jsx)("div", { className: styles$8.timezone, ref: timezoneRef })
  ] });
}
var gridStep = "_gridStep_r7e6h_1";
var isDayStart = "_isDayStart_r7e6h_14";
var styles$7 = {
  gridStep,
  isDayStart
};
function GridStep({ gridStep: gridStep2, timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const textRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const { $gridStepSize } = timelineStore.gridState;
    const { $timeState } = timelineStore.viewState;
    const $data = computed([$timeState, $gridStepSize], (timeState, gridStepSize) => ({ timeState, gridStepSize }));
    const unsubscribe = $data.subscribe(({ timeState, gridStepSize }) => {
      const node = ref.current;
      if (!node) {
        return;
      }
      const width = Math.round(gridStepSize / timeState.scale);
      const left = Math.round((gridStep2 - timeState.start) / timeState.scale - width / 2);
      node.style.left = `${left}px`;
      node.style.width = `${width}px`;
    });
    return () => {
      unsubscribe();
      $data.off();
    };
  }, [gridStep2, timelineStore]);
  (0, import_react.useEffect)(() => {
    const { $viewTimeZone } = timelineStore;
    const { $gridStepSize } = timelineStore.gridState;
    const $data = computed([$viewTimeZone, $gridStepSize], (viewTimeZone, gridStepSize) => ({
      viewTimeZone,
      gridStepSize
    }));
    const unsubscribe = $data.subscribe(({ viewTimeZone, gridStepSize }) => {
      const textNode = textRef.current;
      if (!textNode) {
        return;
      }
      let text = stringifyTime(gridStep2, gridStepSize, viewTimeZone);
      const isDayStart2 = text === "00:00" || text === "00:00:00";
      if (isDayStart2) {
        text = stringifyDay(gridStep2, viewTimeZone);
      }
      textNode.innerHTML = "";
      textNode.appendChild(document.createTextNode(text));
      textNode.classList.toggle(styles$7.isDayStart, isDayStart2);
    });
    return () => {
      unsubscribe();
      $data.off();
    };
  }, [gridStep2, timelineStore]);
  return (0, import_jsx_runtime.jsx)("div", { className: styles$7.gridStep, ref, children: (0, import_jsx_runtime.jsx)("div", { className: styles$7.text, ref: textRef }) });
}
var EnhancedGridStep = (0, import_react.memo)(GridStep);
function GridSteps({ timelineStore }) {
  const { $gridSteps } = timelineStore.gridState;
  const gridSteps = useStore($gridSteps);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: gridSteps.map((gridStep2) => (0, import_jsx_runtime.jsx)(EnhancedGridStep, { gridStep: gridStep2, timelineStore }, gridStep2)) });
}
var SvgMinusLine = (props) => React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, React.createElement("g", { id: "minus-line" }, React.createElement("path", { id: "vector", d: "M20 12H4", stroke: "currentColor", strokeWidth: 1.8, strokeLinecap: "square", strokeLinejoin: "round" })));
var SvgPlusLine = (props) => React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, React.createElement("g", { id: "plus-line" }, React.createElement("path", { id: "vector", d: "M12 4V20M20 12H4", stroke: "currentColor", strokeWidth: 1.8, strokeLinecap: "square", strokeLinejoin: "round" })));
var scaleController = "_scaleController_9iom2_1";
var scaleButton = "_scaleButton_9iom2_16";
var value = "_value_9iom2_35";
var icon$1 = "_icon_9iom2_40";
var styles$6 = {
  scaleController,
  scaleButton,
  value,
  icon: icon$1
};
function ScaleController({ timelineStore }) {
  const { animateScale } = timelineStore.viewState;
  const { $gridStepSize } = timelineStore.gridState;
  const gridStepSize = useStore($gridStepSize);
  const scaleDown = (0, import_react.useCallback)(() => animateScale(2), [animateScale]);
  const scaleUp = (0, import_react.useCallback)(() => animateScale(0.5), [animateScale]);
  const text = (0, import_react.useMemo)(() => stringifyGridStepSize(gridStepSize), [gridStepSize]);
  return (0, import_jsx_runtime.jsxs)("div", { className: styles$6.scaleController, children: [
    (0, import_jsx_runtime.jsx)("div", { className: styles$6.scaleButton, onClick: scaleDown, children: (0, import_jsx_runtime.jsx)(SvgMinusLine, { className: styles$6.icon }) }),
    (0, import_jsx_runtime.jsx)("div", { className: styles$6.value, children: text }),
    (0, import_jsx_runtime.jsx)("div", { className: styles$6.scaleButton, onClick: scaleUp, children: (0, import_jsx_runtime.jsx)(SvgPlusLine, { className: styles$6.icon }) })
  ] });
}
var headerRow = "_headerRow_1083l_1";
var styles$5 = {
  headerRow
};
function Header({
  timelineStore
}) {
  const ref = (0, import_react.useRef)(null);
  const { $settings } = timelineStore;
  const { $timelineSize } = timelineStore.viewState;
  const { showScaleController, showSidebar } = useStore($settings);
  (0, import_react.useEffect)(() => {
    return $timelineSize.subscribe(({ width, headerHeight }) => {
      if (ref.current) {
        ref.current.style.width = `${width}px`;
        ref.current.style.height = `${headerHeight}px`;
      }
    });
  });
  return (0, import_jsx_runtime.jsxs)("div", { className: styles$5.headerRow, ref, children: [
    (0, import_jsx_runtime.jsx)(GridSteps, { timelineStore }),
    showSidebar && (0, import_jsx_runtime.jsx)(ActiveDate, { timelineStore }),
    showScaleController && (0, import_jsx_runtime.jsx)(ScaleController, { timelineStore })
  ] });
}
var EnhancedHeader = (0, import_react.memo)(Header);
var hoveredEvent = "_hoveredEvent_pdbp3_1";
var visible = "_visible_pdbp3_19";
var header = "_header_pdbp3_25";
var time$1 = "_time_pdbp3_31";
var duration = "_duration_pdbp3_36";
var content$1 = "_content_pdbp3_43";
var styles$4 = {
  hoveredEvent,
  visible,
  header,
  time: time$1,
  duration,
  content: content$1
};
var HIDE_TIMEOUT = 100;
function HoveredEvent({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const eventRef = (0, import_react.useRef)(null);
  const hideTimeoutRef = (0, import_react.useRef)(null);
  const [visible2, setVisible] = (0, import_react.useState)(false);
  const { $hoveredEvent, $settings } = timelineStore;
  const { $mouseCoords } = timelineStore.viewState;
  const { $timelineSize } = timelineStore.viewState;
  const hoveredEvent2 = useStore($hoveredEvent);
  const { renderEventPopupContent, eventLineHeight, showHoveredEventPopup } = useStore($settings);
  (0, import_react.useEffect)(() => {
    if (hoveredEvent2 && showHoveredEventPopup) {
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
        hideTimeoutRef.current = null;
      }
      eventRef.current = hoveredEvent2;
      setVisible(true);
    } else {
      hideTimeoutRef.current = setTimeout(() => setVisible(false), HIDE_TIMEOUT);
    }
  }, [hoveredEvent2, showHoveredEventPopup]);
  (0, import_react.useEffect)(
    () => () => {
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
        hideTimeoutRef.current = null;
      }
    },
    []
  );
  const renderedEvent = hoveredEvent2 || eventRef.current;
  (0, import_react.useEffect)(() => {
    if (visible2) {
      const getNodeTop = (rect) => {
        if (!ref.current || !rect) {
          return 0;
        }
        const { headerHeight } = $timelineSize.get();
        const nodeHeight = ref.current.offsetHeight;
        let nodeTop = rect.top + headerHeight - nodeHeight - EVENT_POPUP_OFFSET;
        if (nodeTop <= 0) {
          nodeTop = rect.top + rect.height + headerHeight + EVENT_POPUP_OFFSET;
        }
        return nodeTop;
      };
      const topAnimationController = initAnimationController(getNodeTop(renderedEvent == null ? void 0 : renderedEvent.rect), (value2) => {
        if (ref.current) {
          ref.current.style.top = `${value2}px`;
        }
      });
      if (ref.current) {
        ref.current.style.top = `${getNodeTop(renderedEvent == null ? void 0 : renderedEvent.rect)}px`;
      }
      const unsubscribeHoveredEvent = $hoveredEvent.subscribe((hoveredEvent22) => {
        if (!ref.current || !hoveredEvent22) {
          return;
        }
        const nodeTop = getNodeTop(hoveredEvent22.rect);
        topAnimationController.move(nodeTop, eventLineHeight * 20);
      });
      const unsubscribeMouseCoords = $mouseCoords.subscribe(({ left }) => {
        if (ref.current) {
          const { width } = $timelineSize.get();
          const nodeWidth = ref.current.offsetWidth;
          let nodeLeft = Math.round(left - nodeWidth / 2);
          if (nodeLeft < 4) {
            nodeLeft = nodeLeft = 4;
          } else if (nodeLeft + nodeWidth > width - 4) {
            nodeLeft = width - 4 - nodeWidth;
          }
          ref.current.style.left = `${nodeLeft}px`;
        }
      });
      return () => {
        unsubscribeMouseCoords();
        topAnimationController.reset();
        unsubscribeHoveredEvent();
      };
    }
  }, [visible2, $mouseCoords, $timelineSize]);
  const timeStr = (0, import_react.useMemo)(() => {
    if (!renderedEvent) {
      return null;
    }
    return stringifyTimeRange(renderedEvent.event.start, renderedEvent.event.end);
  }, [renderedEvent]);
  const timeDurationStr = (0, import_react.useMemo)(() => {
    if (!renderedEvent) {
      return null;
    }
    return stringifyTimeDuration(renderedEvent.event.end - renderedEvent.event.start);
  }, [renderedEvent]);
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx(styles$4.hoveredEvent, visible2 && styles$4.visible), ref, children: [
    (0, import_jsx_runtime.jsxs)("div", { className: styles$4.header, children: [
      (0, import_jsx_runtime.jsx)("div", { className: styles$4.time, children: timeStr }),
      timeDurationStr && (0, import_jsx_runtime.jsx)("div", { className: styles$4.duration, children: timeDurationStr })
    ] }),
    renderEventPopupContent && renderedEvent && (0, import_jsx_runtime.jsx)("div", { className: styles$4.content, children: renderEventPopupContent(renderedEvent.event) })
  ] });
}
var EnhancedHoveredEvent = (0, import_react.memo)(HoveredEvent);
var mouseTime = "_mouseTime_1n4o4_1";
var time = "_time_1n4o4_11";
var showSeconds = "_showSeconds_1n4o4_24";
var styles$3 = {
  mouseTime,
  time,
  showSeconds
};
function MouseTime({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const textRef = (0, import_react.useRef)(null);
  const visibleRef = (0, import_react.useRef)(false);
  const { $gridStepSize } = timelineStore.gridState;
  const { $timeState, $mouseTime, $timelineSize } = timelineStore.viewState;
  const { $viewTimeZone, $settings } = timelineStore;
  const { showMouseTime } = useStore($settings);
  (0, import_react.useEffect)(() => {
    if (!showMouseTime) {
      visibleRef.current = false;
      return;
    }
    const $data = computed(
      [$mouseTime, $timeState, $gridStepSize, $viewTimeZone, $timelineSize],
      (mouseTime2, timeState, gridStepSize, viewTimeZone, timelineSize) => ({
        mouseTime: mouseTime2,
        timeState,
        gridStepSize,
        viewTimeZone,
        timelineSize
      })
    );
    const unsubscribe = $data.subscribe(({ mouseTime: mouseTime2, timeState, gridStepSize, viewTimeZone, timelineSize }) => {
      if (!ref.current || !textRef.current) {
        return;
      }
      if (!mouseTime2) {
        if (visibleRef.current) {
          visibleRef.current = false;
          ref.current.style.display = "none";
        }
        return;
      }
      if (!visibleRef.current) {
        visibleRef.current = true;
        ref.current.style.display = "block";
      }
      const left = Math.round((mouseTime2 - timeState.start) / timeState.scale - 1);
      const top = timelineSize.headerHeight;
      ref.current.style.left = `${left}px`;
      ref.current.style.top = `${top}px`;
      const timeStr = stringifyTime(mouseTime2, gridStepSize, viewTimeZone);
      textRef.current.innerHTML = "";
      textRef.current.appendChild(document.createTextNode(timeStr));
      if (gridStepSize < MINUTE_MS) {
        textRef.current.classList.add(styles$3.showSeconds);
      } else {
        textRef.current.classList.remove(styles$3.showSeconds);
      }
    });
    return () => {
      unsubscribe();
      $data.off();
    };
  }, [$mouseTime, $timeState, $gridStepSize, $viewTimeZone, $timelineSize, showMouseTime]);
  if (!showMouseTime) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$3.mouseTime, ref, children: (0, import_jsx_runtime.jsx)("div", { className: styles$3.time, ref: textRef }) });
}
var EnhancedMouseTime = (0, import_react.memo)(MouseTime);
var renderedEvents = "_renderedEvents_1kztm_1";
var event = "_event_1kztm_7";
var styles$2 = {
  renderedEvents,
  event
};
function Event({ event: event2, rect, renderEventContent }) {
  const content2 = (0, import_react.useMemo)(() => renderEventContent(event2), [event2, renderEventContent]);
  return (0, import_jsx_runtime.jsx)("div", { className: styles$2.event, style: rect, children: content2 });
}
var EnhancedEvent = (0, import_react.memo)(Event);
function RenderedEvents({ timelineStore }) {
  const ref = (0, import_react.useRef)(null);
  const { $renderedEvents, $settings } = timelineStore;
  const { $timelineSize } = timelineStore.viewState;
  const { renderEventContent } = useStore($settings);
  const renderedEvents2 = useStore($renderedEvents);
  (0, import_react.useEffect)(() => {
    return $timelineSize.subscribe((timelineSize) => {
      if (!ref.current) {
        return;
      }
      const { dataWidth, dataHeight } = timelineSize;
      ref.current.style.width = `${dataWidth}px`;
      ref.current.style.height = `${dataHeight}px`;
    });
  }, [$timelineSize, renderEventContent]);
  if (!renderEventContent) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$2.renderedEvents, ref, children: renderedEvents2.map(({ event: event2, rect }) => (0, import_jsx_runtime.jsx)(EnhancedEvent, { rect, event: event2, renderEventContent }, event2.id)) });
}
var EnhancedRenderedEvents = (0, import_react.memo)(RenderedEvents);
var sidebar = "_sidebar_7zle8_1";
var content = "_content_7zle8_9";
var row = "_row_7zle8_16";
var highlight = "_highlight_7zle8_23";
var needHighlight = "_needHighlight_7zle8_33";
var expanded = "_expanded_7zle8_34";
var highlightHovered = "_highlightHovered_7zle8_35";
var hovered = "_hovered_7zle8_35";
var rowContent = "_rowContent_7zle8_39";
var rowInside = "_rowInside_7zle8_45";
var rowTitle = "_rowTitle_7zle8_52";
var crossEventsStrategy = "_crossEventsStrategy_7zle8_60";
var loading = "_loading_7zle8_72";
var expander = "_expander_7zle8_83";
var icon = "_icon_7zle8_98";
var styles$1 = {
  sidebar,
  content,
  row,
  highlight,
  needHighlight,
  expanded,
  highlightHovered,
  hovered,
  rowContent,
  rowInside,
  rowTitle,
  crossEventsStrategy,
  loading,
  expander,
  icon
};
function Loading({
  timelineStore
}) {
  const ref = (0, import_react.useRef)(null);
  const topRef = (0, import_react.useRef)(0);
  const { $settings } = timelineStore;
  const { $rowsLoading, $rowsIds, $rowsHeight, $rowsTop } = useStore(timelineStore.$rowsStore);
  const loading2 = useStore($rowsLoading);
  (0, import_react.useEffect)(() => {
    if (!loading2) {
      topRef.current = 0;
      return;
    }
    const $data = computed([$rowsIds, $rowsTop, $rowsHeight, $settings], (rowsIds, rowsTop, rowsHeight, settings) => ({
      rowsIds,
      rowsTop,
      rowsHeight,
      settings
    }));
    const unsubscribe = $data.subscribe(({ rowsIds, rowsTop, rowsHeight, settings }) => {
      let top = settings.dataViewPadding;
      if (rowsIds.length > 0) {
        const lastId = rowsIds[rowsIds.length - 1];
        const lastRowTop = rowsTop[lastId];
        const lastRowHeight = rowsHeight[lastId];
        top = lastRowTop + lastRowHeight;
      }
      if (topRef.current !== top && ref.current) {
        topRef.current = top;
        ref.current.style.top = `${top}px`;
      }
    });
    return () => {
      unsubscribe();
      $data.off();
    };
  }, [loading2, $rowsIds, $rowsHeight, $rowsTop, $settings]);
  if (!loading2) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$1.loading, ref, children: "Loading..." });
}
var EnhancedLoading = (0, import_react.memo)(Loading);
var SvgChevronRightLine = (props) => React.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, React.createElement("g", { id: "chevron-right-line" }, React.createElement("path", { id: "vector", d: "M8.00293 4.71191L15.2896 11.9985L8 19.2881", stroke: "currentColor", strokeWidth: 1.8 })));
function useRowConfig(timelineStore, row2) {
  const { $rowsCrossEventsStrategy, $rowsNestedLevel, $rowsExpanded } = useStore(timelineStore.$rowsStore);
  const [crossEventsStrategy2, setCrossEventsStrategy] = (0, import_react.useState)(
    $rowsCrossEventsStrategy.get()[row2.id]
  );
  const [rowNestedLevel, setRowNestedLevel] = (0, import_react.useState)($rowsNestedLevel.get()[row2.id]);
  const [rowExpanded, setRowExpanded] = (0, import_react.useState)($rowsExpanded.get()[row2.id]);
  (0, import_react.useEffect)(() => {
    const unsubscribeCrossEventsStrategy = $rowsCrossEventsStrategy.subscribe((rowsCrossEventsStrategy) => {
      const newStrategy = rowsCrossEventsStrategy[row2.id];
      if (crossEventsStrategy2 !== newStrategy) {
        setCrossEventsStrategy(newStrategy);
      }
    });
    const unsubscribeRowsNestedLevel = $rowsNestedLevel.subscribe((rowsNestedLevels) => {
      const level = rowsNestedLevels[row2.id];
      if (level !== rowNestedLevel) {
        setRowNestedLevel(level);
      }
    });
    const unsubscribeRowsExpanded = $rowsExpanded.subscribe((rowsExpanded) => {
      const expanded2 = rowsExpanded[row2.id];
      if (expanded2 !== rowExpanded) {
        setRowExpanded(expanded2);
      }
    });
    return () => {
      unsubscribeCrossEventsStrategy();
      unsubscribeRowsNestedLevel();
      unsubscribeRowsExpanded();
    };
  }, [
    $rowsCrossEventsStrategy,
    $rowsNestedLevel,
    $rowsExpanded,
    row2,
    crossEventsStrategy2,
    rowNestedLevel,
    rowExpanded
  ]);
  return [crossEventsStrategy2, rowNestedLevel, rowExpanded];
}
function renderRowDefault({
  row: row2,
  crossEventsStrategy: crossEventsStrategy2,
  onChangeCrossEventsStrategy
}) {
  return (0, import_jsx_runtime.jsxs)("div", { className: styles$1.rowInside, children: [
    (0, import_jsx_runtime.jsx)("div", { className: clsx(styles$1.rowTitle), children: row2.title }),
    onChangeCrossEventsStrategy && (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: styles$1.crossEventsStrategy,
        onClick: () => onChangeCrossEventsStrategy(
          crossEventsStrategy2 === "split-crossed-events" ? "overlay-crossed-events" : "split-crossed-events"
        ),
        children: crossEventsStrategy2 === "split-crossed-events" ? "Split events" : "Overlay events"
      }
    )
  ] });
}
function getRowTotalHeight(rowId, rowsMap, rowsHeight, settings) {
  let height = rowsHeight[rowId];
  const { children } = rowsMap[rowId];
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const childRow = children[i];
      height += getRowTotalHeight(childRow.id, rowsMap, rowsHeight);
    }
  }
  return height;
}
function Row({
  timelineStore,
  row: row2
}) {
  const ref = (0, import_react.useRef)(null);
  const highlightRef = (0, import_react.useRef)(null);
  const topRef = (0, import_react.useRef)(0);
  const heightRef = (0, import_react.useRef)(0);
  const hoveredRef = (0, import_react.useRef)(false);
  const { $hoveredRow, $settings } = timelineStore;
  const { $rowsTop, $rowsHeight, $rowsCrossEventsStrategy, $rowsExpanded, $rowsMap } = useStore(
    timelineStore.$rowsStore
  );
  const settings = useStore($settings);
  const [crossEventsStrategy2, nestedLevel, expanded2] = useRowConfig(timelineStore, row2);
  const hasChildren = Boolean($rowsMap.get()[row2.id].children);
  const toggleExpanded = (0, import_react.useCallback)(() => {
    $rowsExpanded.setKey(row2.id, !expanded2);
  }, [$rowsExpanded, expanded2, row2]);
  (0, import_react.useEffect)(() => {
    return $hoveredRow.subscribe((hoveredRow) => {
      if (!ref.current) {
        hoveredRef.current = false;
        return;
      }
      const isHovered = hoveredRow && hoveredRow[hoveredRow.length - 1] === row2.id;
      if (isHovered && !hoveredRef.current) {
        hoveredRef.current = true;
        ref.current.classList.add(styles$1.hovered);
      }
      if (!isHovered && hoveredRef.current) {
        hoveredRef.current = false;
        ref.current.classList.remove(styles$1.hovered);
      }
    });
  }, [row2, $hoveredRow]);
  const setCrossEventsStrategy = (0, import_react.useCallback)(
    (crossEventsStrategy22) => {
      if (settings.canChangeCrossEventsStrategy) {
        $rowsCrossEventsStrategy.setKey(row2.id, crossEventsStrategy22);
      }
    },
    [$rowsCrossEventsStrategy, row2, settings]
  );
  (0, import_react.useEffect)(() => {
    const rowsTop = $rowsTop.get();
    const rowTop = rowsTop[row2.id];
    const node = ref.current;
    if (node) {
      node.style.transform = `translate(0, ${rowTop}px)`;
    }
    const unsubscribeTop = $rowsTop.listen((value2) => {
      const top = value2[row2.id];
      if (topRef.current === top) {
        return;
      }
      topRef.current = top;
      const node2 = ref.current;
      if (node2) {
        node2.style.transform = `translate(0, ${top}px)`;
      }
    });
    const unsubscribeHeight = $rowsHeight.subscribe((rowsHeight) => {
      const height = rowsHeight[row2.id];
      if (heightRef.current !== height) {
        heightRef.current = height;
        const node2 = ref.current;
        if (node2) {
          node2.style.height = `${height}px`;
        }
      }
      if (highlightRef.current) {
        const rowsMap = $rowsMap.get();
        const rowHeight = getRowTotalHeight(row2.id, rowsMap, rowsHeight);
        const highlightHeight = rowHeight - 2;
        highlightRef.current.style.height = `${highlightHeight}px`;
      }
    });
    return () => {
      unsubscribeTop();
      unsubscribeHeight();
    };
  }, [row2, $rowsTop, $rowsHeight, $rowsMap, settings]);
  const renderOptions = (0, import_react.useMemo)(
    () => ({
      row: row2,
      settings,
      crossEventsStrategy: crossEventsStrategy2,
      nestedLevel,
      hasChildren,
      expanded: expanded2,
      onChangeCrossEventsStrategy: settings.canChangeCrossEventsStrategy ? setCrossEventsStrategy : null
    }),
    [row2, crossEventsStrategy2, setCrossEventsStrategy, hasChildren, expanded2, nestedLevel, settings]
  );
  const renderRow = settings.renderSidebarRowContent || renderRowDefault;
  const content2 = (0, import_jsx_runtime.jsxs)("div", { className: styles$1.rowContent, style: { height: settings.rowPadding * 2 + settings.eventLineHeight - 2 }, children: [
    hasChildren && (0, import_jsx_runtime.jsx)("div", { className: clsx(styles$1.expander), onClick: toggleExpanded, children: (0, import_jsx_runtime.jsx)(SvgChevronRightLine, { className: styles$1.icon }) }),
    renderRow(renderOptions)
  ] });
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      className: clsx(
        styles$1.row,
        hasChildren && styles$1.hasChildren,
        settings.highlightHoveredRow && styles$1.highlightHovered,
        expanded2 && styles$1.expanded,
        nestedLevel === 0 && styles$1.needHighlight
      ),
      ref,
      style: { left: nestedLevel * 32 },
      children: (0, import_jsx_runtime.jsx)("div", { className: styles$1.highlight, ref: hasChildren && nestedLevel === 0 ? highlightRef : void 0, children: content2 })
    }
  );
}
var EnhancedRow = (0, import_react.memo)(Row);
function Content({
  timelineStore
}) {
  const ref = (0, import_react.useRef)(null);
  const { $containerScrollTop } = timelineStore.viewState;
  const { $visibleRows, $rowsMap, $rowsExpanded } = useStore(timelineStore.$rowsStore);
  const visibleRows = useStore($visibleRows);
  const rowsMap = useStore($rowsMap);
  const rowsExpanded = useStore($rowsExpanded);
  const rowsList = (0, import_react.useMemo)(
    () => getNestedRowsIds(visibleRows, rowsMap, rowsExpanded),
    [visibleRows, rowsMap, rowsExpanded]
  );
  (0, import_react.useEffect)(() => {
    return $containerScrollTop.subscribe((top) => {
      if (ref.current) {
        ref.current.style.top = `${-top}px`;
      }
    });
  }, [$containerScrollTop]);
  return (0, import_jsx_runtime.jsxs)("div", { className: styles$1.content, ref, children: [
    rowsList.map((id) => (0, import_jsx_runtime.jsx)(EnhancedRow, { row: rowsMap[id], timelineStore }, id)),
    (0, import_jsx_runtime.jsx)(EnhancedLoading, { timelineStore })
  ] });
}
function Sidebar({
  timelineStore
}) {
  const ref = (0, import_react.useRef)(null);
  const { $timelineSize } = timelineStore.viewState;
  const { $settings } = timelineStore;
  const { showSidebar } = useStore($settings);
  (0, import_react.useEffect)(() => {
    if (!showSidebar) {
      return;
    }
    return $timelineSize.subscribe(({ sidebarWidth, sidebarHeight, headerHeight }) => {
      if (ref.current) {
        ref.current.style.width = `${sidebarWidth}px`;
        ref.current.style.height = `${sidebarHeight}px`;
        ref.current.style.top = `${headerHeight}px`;
      }
    });
  }, [$timelineSize, showSidebar]);
  if (!showSidebar) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: styles$1.sidebar, ref, children: (0, import_jsx_runtime.jsx)(Content, { timelineStore }) });
}
var EnhancedSidebar = (0, import_react.memo)(Sidebar);
var ANIMATION_DISTANCE_FACTOR = 500;
function initEventsTopAnimation(requestRender) {
  let positions = /* @__PURE__ */ new Map();
  const animatingEventsTop = /* @__PURE__ */ new Map();
  const animationState = /* @__PURE__ */ new Map();
  const animateEventTop = (eventId, topFrom, topTo) => {
    let animationController = animationState.get(eventId);
    if (!animationController) {
      animatingEventsTop.set(eventId, topFrom);
      animationController = initAnimationController(
        topFrom,
        (value2) => {
          animatingEventsTop.set(eventId, value2);
          requestRender();
        },
        () => {
          animationState.delete(eventId);
          animatingEventsTop.delete(eventId);
          animationController == null ? void 0 : animationController.reset();
          requestRender();
        }
      );
      animationState.set(eventId, animationController);
    }
    animationController.move(topTo, ANIMATION_DISTANCE_FACTOR);
  };
  const requestEventTopAnimation = (eventId, position) => {
    const currentPosition = positions.get(eventId);
    let eventTop = position.top;
    if (currentPosition && (currentPosition.rowId !== position.rowId || currentPosition.lineIndex !== position.lineIndex)) {
      animateEventTop(eventId, currentPosition.top, position.top);
    }
    const animatingTop = animatingEventsTop.get(eventId);
    if (animatingTop !== void 0) {
      eventTop = animatingTop;
      const animationController = animationState.get(eventId);
      if (animationController) {
        animationController.move(position.top, ANIMATION_DISTANCE_FACTOR);
      }
    }
    return eventTop;
  };
  const updateEventsPositions = (newPositions) => {
    positions = newPositions;
  };
  const eventsTopAnimation = {
    updateEventsPositions,
    requestEventTopAnimation
  };
  const reset = () => {
    animationState.forEach((item) => item.reset());
  };
  return [eventsTopAnimation, reset];
}
var ANGLE_RIGHT$1 = 0;
var ANGLE_BOTTOM$1 = Math.PI / 2;
var ANGLE_LEFT$1 = Math.PI;
var ANGLE_TOP$1 = 3 * Math.PI / 2;
var EVENT_MIN_WIDTH$3 = 1;
function renderActiveEvent(event2, colors, ctx, left, top, width, height, borderRadius) {
  const gap = 3 * DEVICE_PIXEL_RATIO;
  left = left - gap;
  top = top - gap;
  width = width + gap * 2;
  height = height + gap * 2;
  borderRadius = borderRadius + gap;
  const radius = Math.round(Math.min(borderRadius, width / 2, height / 2));
  if (radius <= EVENT_MIN_WIDTH$3 * DEVICE_PIXEL_RATIO) {
    ctx.fillRect(left, top, width, height);
    return;
  }
  ctx.strokeStyle = event2.highlightColor || event2.color || colors.eventActiveStroke;
  ctx.lineWidth = DEVICE_PIXEL_RATIO * 2;
  ctx.beginPath();
  ctx.moveTo(left, top + radius);
  ctx.arc(left + radius, top + radius, radius, ANGLE_LEFT$1, ANGLE_TOP$1);
  ctx.lineTo(left + width - radius, top);
  ctx.arc(left + width - radius, top + radius, radius, ANGLE_TOP$1, ANGLE_RIGHT$1);
  ctx.lineTo(left + width, top + height - radius);
  ctx.arc(left + width - radius, top + height - radius, radius, ANGLE_RIGHT$1, ANGLE_BOTTOM$1);
  ctx.lineTo(left + radius, top + height);
  ctx.arc(left + radius, top + height - radius, radius, ANGLE_BOTTOM$1, ANGLE_LEFT$1);
  ctx.lineTo(left, top + radius);
  ctx.stroke();
}
var ANGLE_RIGHT = 0;
var ANGLE_BOTTOM = Math.PI / 2;
var ANGLE_LEFT = Math.PI;
var ANGLE_TOP = 3 * Math.PI / 2;
var EVENT_MIN_WIDTH$2 = 1;
function renderBorderRadiusEvent(ctx, left, top, width, height, borderRadius) {
  const radius = Math.round(Math.min(borderRadius, width / 2, height / 2));
  if (radius <= EVENT_MIN_WIDTH$2 * DEVICE_PIXEL_RATIO) {
    ctx.fillRect(left, top, width, height);
    return;
  }
  ctx.beginPath();
  ctx.moveTo(left, top + radius);
  ctx.arc(left + radius, top + radius, radius, ANGLE_LEFT, ANGLE_TOP);
  ctx.lineTo(left + width - radius, top);
  ctx.arc(left + width - radius, top + radius, radius, ANGLE_TOP, ANGLE_RIGHT);
  ctx.lineTo(left + width, top + height - radius);
  ctx.arc(left + width - radius, top + height - radius, radius, ANGLE_RIGHT, ANGLE_BOTTOM);
  ctx.lineTo(left + radius, top + height);
  ctx.arc(left + radius, top + height - radius, radius, ANGLE_BOTTOM, ANGLE_LEFT);
  ctx.lineTo(left, top + radius);
  ctx.fill();
}
var EVENT_MIN_WIDTH$1 = 1;
var getRenderedEventSetter = (renderedEvents2, settings) => (event2, canvasLeft, canvasTop, canvasWidth, canvasHeight) => {
  const width = Math.round(canvasWidth / DEVICE_PIXEL_RATIO);
  if (width >= settings.eventContentMinWidth) {
    const top = Math.round(canvasTop / DEVICE_PIXEL_RATIO);
    const left = Math.round(canvasLeft / DEVICE_PIXEL_RATIO);
    const height = Math.round(canvasHeight / DEVICE_PIXEL_RATIO);
    renderedEvents2.push({ rect: { left, top, width, height }, event: event2 });
  }
};
function renderEvents(ctx, timeState, containerScrollTop, timelineSize, visibleRows, rowsTop, rowsEvents, hoveredEvent2, settings, eventsTopAnimation, rowsMap, activeEvent2, colors) {
  const rowsIds = getNestedRowsIds(visibleRows, rowsMap);
  const hoveredEventId = settings.highlightHoveredEvent && (hoveredEvent2 == null ? void 0 : hoveredEvent2.event.id);
  const activeEventId = settings.highlightHoveredEvent && (activeEvent2 == null ? void 0 : activeEvent2.id);
  const { sidebarWidth, dataHeight, dataWidth } = timelineSize;
  const canvasWidth = dataWidth * DEVICE_PIXEL_RATIO;
  const canvasHeight = dataHeight * DEVICE_PIXEL_RATIO;
  let hoveredEventRect = null;
  let activeEventRect = null;
  const nextEventsPositions = /* @__PURE__ */ new Map();
  const borderRadius = settings.eventBorderRadius * DEVICE_PIXEL_RATIO;
  const renderedEvents2 = [];
  const setRenderedEvent = settings.renderEventContent ? getRenderedEventSetter(renderedEvents2, settings) : null;
  for (let rowIndex = 0; rowIndex < rowsIds.length; rowIndex++) {
    const rowId = rowsIds[rowIndex];
    const rowEventsLines = rowsEvents[rowId];
    const rowTop = (rowsTop[rowId] - containerScrollTop) * DEVICE_PIXEL_RATIO;
    if (rowEventsLines && rowEventsLines.length > 0) {
      for (let lineIndex = 0; lineIndex < rowEventsLines.length; lineIndex++) {
        const lineEvents = rowEventsLines[lineIndex];
        const lineTop = Math.round(
          lineIndex * (settings.eventLineHeight + settings.eventLineMargin) * DEVICE_PIXEL_RATIO
        );
        for (let eventIndex = 0; eventIndex < lineEvents.length; eventIndex++) {
          const event2 = lineEvents[eventIndex];
          const left = Math.round(
            ((event2.start - timeState.start) / timeState.scale - sidebarWidth) * DEVICE_PIXEL_RATIO
          );
          let top = lineTop + rowTop + settings.rowPadding * DEVICE_PIXEL_RATIO;
          const width = Math.max(
            Math.round((event2.end - event2.start) / timeState.scale * DEVICE_PIXEL_RATIO),
            EVENT_MIN_WIDTH$1
          );
          const height = settings.eventLineHeight * DEVICE_PIXEL_RATIO;
          if (left + width < 0 || left > canvasWidth || top + height < 0 || top > canvasHeight) {
            continue;
          }
          const eventPosition = { rowId, lineIndex, top };
          nextEventsPositions.set(event2.id, eventPosition);
          top = eventsTopAnimation.requestEventTopAnimation(event2.id, eventPosition);
          ctx.fillStyle = event2.color;
          if (event2.id === activeEventId) {
            activeEventRect = {
              left,
              top,
              width,
              height
            };
          } else if (event2.id === hoveredEventId) {
            hoveredEventRect = {
              left,
              top,
              width,
              height
            };
          } else {
            if (borderRadius === 0) {
              ctx.fillRect(left, top, width, height);
            } else {
              renderBorderRadiusEvent(ctx, left, top, width, height, borderRadius);
            }
          }
          if (setRenderedEvent) {
            setRenderedEvent(event2, left, top, width, height);
          }
        }
      }
    }
  }
  if (hoveredEventRect) {
    const { left, top, width, height } = hoveredEventRect;
    let gap = DEVICE_PIXEL_RATIO;
    if (hoveredEvent2) {
      if (hoveredEvent2.event.highlightColor) {
        gap = 0;
        ctx.fillStyle = hoveredEvent2.event.highlightColor;
      } else {
        ctx.fillStyle = hoveredEvent2.event.color;
      }
    }
    if (borderRadius === 0) {
      ctx.fillRect(left - gap, top - gap, width + gap * 2, height + gap * 2);
    } else {
      renderBorderRadiusEvent(ctx, left - gap, top - gap, width + gap * 2, height + gap * 2, borderRadius + gap);
    }
  }
  if (activeEventRect) {
    const { left, top, width, height } = activeEventRect;
    let gap = DEVICE_PIXEL_RATIO;
    if (activeEvent2) {
      if (activeEvent2.highlightColor) {
        gap = 0;
        ctx.fillStyle = activeEvent2.highlightColor;
      } else {
        ctx.fillStyle = activeEvent2.color;
      }
    }
    if (borderRadius === 0) {
      ctx.fillRect(left - gap, top - gap, width + gap * 2, height + gap * 2);
    } else {
      renderBorderRadiusEvent(ctx, left - gap, top - gap, width + gap * 2, height + gap * 2, borderRadius + gap);
    }
    if (activeEvent2) {
      renderActiveEvent(
        activeEvent2,
        colors,
        ctx,
        left - gap,
        top - gap,
        width + gap * 2,
        height + gap * 2,
        borderRadius + gap
      );
    }
  }
  eventsTopAnimation.updateEventsPositions(nextEventsPositions);
  return renderedEvents2;
}
function renderGrid(ctx, gridSteps, timeState, timelineSize, colors) {
  const height = timelineSize.dataHeight * DEVICE_PIXEL_RATIO;
  const sidebarWidth = timelineSize.sidebarWidth;
  ctx.fillStyle = colors.border;
  for (let i = 0; i < gridSteps.length; i++) {
    const time2 = gridSteps[i];
    const left = Math.round((time2 - timeState.start) / timeState.scale - sidebarWidth);
    const lineWidth = 1 * DEVICE_PIXEL_RATIO;
    ctx.fillRect(left * DEVICE_PIXEL_RATIO, 0, lineWidth, height);
  }
}
function renderHoveredRow(ctx, hoveredRow, rowsTop, rowsHeight, containerScrollTop, timelineSize, colors) {
  if (hoveredRow === null) {
    return;
  }
  ctx.fillStyle = colors.rowHoverBg;
  const lastHoveredRow = hoveredRow[hoveredRow.length - 1];
  const rowTop = rowsTop[lastHoveredRow];
  const rowHeight = rowsHeight[lastHoveredRow];
  const { width } = timelineSize;
  const left = 0;
  const top = rowTop - containerScrollTop;
  ctx.fillRect(
    left * DEVICE_PIXEL_RATIO,
    top * DEVICE_PIXEL_RATIO,
    width * DEVICE_PIXEL_RATIO,
    rowHeight * DEVICE_PIXEL_RATIO
  );
}
function initRenderer(ctx, viewState, gridState, $visibleRows, $rowsTop, $rowsHeight, $rowsEvents, $hoveredRow, $hoveredEvent, $colors, $settings, $renderedEvents, $rowsMap, $activeEvent) {
  const { $timelineSize, $timeState, $containerScrollTop } = viewState;
  const { $gridSteps } = gridState;
  const $data = computed(
    [
      $timelineSize,
      $gridSteps,
      $timeState,
      $containerScrollTop,
      $visibleRows,
      $rowsTop,
      $rowsHeight,
      $rowsEvents,
      $hoveredRow,
      $hoveredEvent,
      $colors,
      $settings,
      $rowsMap,
      $activeEvent
    ],
    (timelineSize, gridSteps, timeState, containerScrollTop, visibleRows, rowsTop, rowsHeight, rowsEvents, hoveredRow, hoveredEvent2, colors, settings, rowsMap, activeEvent2) => ({
      timelineSize,
      gridSteps,
      timeState,
      containerScrollTop,
      visibleRows,
      rowsTop,
      rowsHeight,
      rowsEvents,
      hoveredRow,
      hoveredEvent: hoveredEvent2,
      colors,
      settings,
      rowsMap,
      activeEvent: activeEvent2
    })
  );
  const [eventsTopAnimation, resetEventsAnimation] = initEventsTopAnimation(() => requestRender());
  const render = () => {
    const {
      timelineSize,
      gridSteps,
      timeState,
      containerScrollTop,
      visibleRows,
      rowsTop,
      rowsHeight,
      rowsEvents,
      hoveredRow,
      hoveredEvent: hoveredEvent2,
      colors,
      settings,
      rowsMap,
      activeEvent: activeEvent2
    } = $data.get();
    const width = timelineSize.dataWidth * DEVICE_PIXEL_RATIO;
    const height = timelineSize.dataHeight * DEVICE_PIXEL_RATIO;
    ctx.clearRect(0, 0, width, height);
    if (settings.renderGridLines) {
      renderGrid(ctx, gridSteps, timeState, timelineSize, colors);
    }
    if (settings.highlightHoveredRow) {
      renderHoveredRow(ctx, hoveredRow, rowsTop, rowsHeight, containerScrollTop, timelineSize, colors);
    }
    const renderedEvents2 = renderEvents(
      ctx,
      timeState,
      containerScrollTop,
      timelineSize,
      visibleRows,
      rowsTop,
      rowsEvents,
      hoveredEvent2,
      settings,
      eventsTopAnimation,
      rowsMap,
      activeEvent2,
      colors
    );
    if (settings.renderEventContent) {
      $renderedEvents.set(renderedEvents2);
    }
  };
  let renderPlanned = false;
  const requestRender = () => {
    if (renderPlanned) {
      return;
    }
    renderPlanned = true;
    requestAnimationFrame(() => {
      render();
      renderPlanned = false;
    });
  };
  const unsubscribe = $data.subscribe(requestRender);
  const reset = () => {
    unsubscribe();
    resetEventsAnimation();
    $data.off();
  };
  return reset;
}
function updateSize(canvasNode, $timelineSize) {
  return $timelineSize.subscribe((timelineSize) => {
    const width = timelineSize.dataWidth;
    const height = timelineSize.dataHeight;
    canvasNode.style.width = `${width}px`;
    canvasNode.style.height = `${height}px`;
    canvasNode.width = width * DEVICE_PIXEL_RATIO;
    canvasNode.height = height * DEVICE_PIXEL_RATIO;
  });
}
function initCanvas(canvasNode, viewState, gridState, $rowsStore, $rowsEvents, $hoveredRow, $hoveredEvent, $colors, $settings, $renderedEvents, $activeEvent) {
  const { $timelineSize } = viewState;
  const unsubscribe = updateSize(canvasNode, $timelineSize);
  const ctx = canvasNode.getContext("2d");
  let resetRenderer = null;
  const unsubscribeRowsStore = $rowsStore.subscribe((rowsStore) => {
    if (resetRenderer) {
      resetRenderer();
    }
    const { $visibleRows, $rowsTop, $rowsHeight, $rowsMap } = rowsStore;
    resetRenderer = initRenderer(
      ctx,
      viewState,
      gridState,
      $visibleRows,
      $rowsTop,
      $rowsHeight,
      $rowsEvents,
      $hoveredRow,
      $hoveredEvent,
      $colors,
      $settings,
      $renderedEvents,
      $rowsMap,
      $activeEvent
    );
  });
  const reset = () => {
    unsubscribe();
    unsubscribeRowsStore();
    if (resetRenderer) {
      resetRenderer();
    }
  };
  return reset;
}
var transparentColor = "rgba(0,0,0,0)";
var whiteColor = "#ffffff";
function getColors(timelineNode) {
  const style = getComputedStyle(timelineNode);
  const background = style.getPropertyValue("--timeline--background-color") || whiteColor;
  const border = style.getPropertyValue("--timeline--border-tertiary-color") || transparentColor;
  const rowHoverBg = style.getPropertyValue("--timeline--background-secondary-color") || transparentColor;
  const eventHoverStroke = style.getPropertyValue("--timeline--event-hover-stroke-color") || transparentColor;
  const eventActiveStroke = style.getPropertyValue("--timeline--event-active-stroke-color") || transparentColor;
  return { background, border, rowHoverBg, eventHoverStroke, eventActiveStroke };
}
function initColors(timelineNode) {
  const [$colors, reset] = createAtom(getColors(timelineNode));
  const updateColors = () => {
    $colors.set(getColors(timelineNode));
  };
  return [$colors, updateColors, reset];
}
function initCurrentTime() {
  const [$currentTime, resetAtom] = createAtom(Date.now());
  const interval = setInterval(() => {
    $currentTime.set(Date.now());
  }, 5e3);
  const reset = () => {
    clearInterval(interval);
    resetAtom();
  };
  return [$currentTime, reset];
}
function initLoader(storage, getEvents2, eventsLoadStepSize) {
  let stopped = false;
  const activeSet = /* @__PURE__ */ new Set();
  const queueSet = /* @__PURE__ */ new Set();
  const queue = [];
  const processQueue = async () => {
    if (stopped || queue.length === 0 || activeSet.size >= MAX_PARALLEL_EVENTS_REQUEST) {
      return;
    }
    const { rowId, from } = queue.shift();
    const key = `${rowId}-${from}`;
    queueSet.delete(key);
    activeSet.add(key);
    const events = await getEvents2(rowId, from, from + eventsLoadStepSize);
    if (stopped) {
      return;
    }
    storage.set(rowId, from, events);
    activeSet.delete(key);
    processQueue();
  };
  const load = (rowId, from) => {
    if (stopped || storage.getChunk(rowId, from)) {
      return;
    }
    const key = `${rowId}-${from}`;
    if (activeSet.has(key) || queueSet.has(key)) {
      return;
    }
    queue.push({ rowId, from });
    queueSet.add(key);
    processQueue();
  };
  const cancel = (rowId, from) => {
    if (stopped) {
      return;
    }
    const key = `${rowId}-${from}`;
    if (queueSet.has(key)) {
      const index = queue.findIndex((value2) => value2.from === from && value2.rowId === rowId);
      if (index) {
        queue.splice(index, 1);
        queueSet.delete(key);
      }
    }
  };
  const reset = () => {
    stopped = true;
  };
  return [load, cancel, reset];
}
function initStorage(dataTZOffset, eventsLoadStepSize) {
  const storage = new EventsStorage(dataTZOffset, eventsLoadStepSize);
  const reset = () => {
    storage.reset();
  };
  return [storage, reset];
}
function getDiff(currentVisibleCells, eventsLoadSteps, visibleRows, rowsMap) {
  const allRowsIds = getNestedRowsIds(visibleRows, rowsMap);
  const newVisibleCells = /* @__PURE__ */ new Map();
  const added = [];
  const rowsIds = allRowsIds.filter((rowId) => {
    const rowItem = rowsMap[rowId];
    return !rowItem.noEvents;
  });
  for (let i = 0; i < eventsLoadSteps.length; i++) {
    for (let j = 0; j < rowsIds.length; j++) {
      const from = eventsLoadSteps[i];
      const rowId = rowsIds[j];
      const key = `${rowId}-${from}`;
      const option = { rowId, from };
      newVisibleCells.set(key, option);
      if (currentVisibleCells.has(key)) {
        currentVisibleCells.delete(key);
      } else {
        added.push(option);
      }
    }
  }
  const removed = Array.from(currentVisibleCells.values());
  return [newVisibleCells, added, removed];
}
function initVisibleEventsLoader($viewRangeTime, rowsStore, loadEvents, cancelLoadEvents, dataTZOffset, eventsLoadStepSize) {
  let hash = "";
  let currentVisibleCells = /* @__PURE__ */ new Map();
  const $eventsLoadSteps = computed(
    $viewRangeTime,
    (viewRangeTime) => getEventsLoadSteps(viewRangeTime, eventsLoadStepSize, dataTZOffset)
  );
  const { $visibleRows, $rowsMap } = rowsStore;
  const $data = computed([$eventsLoadSteps, $visibleRows, $rowsMap], (eventsLoadSteps, visibleRows, rowsMap) => ({
    eventsLoadSteps,
    visibleRows,
    rowsMap
  }));
  const unsubscribe = $data.subscribe(({ eventsLoadSteps, visibleRows, rowsMap }) => {
    const newHash = `${eventsLoadSteps.join("-")}:${visibleRows.join("-")}`;
    if (hash === newHash) {
      return;
    }
    hash = newHash;
    const [newVisibleCells, added, removed] = getDiff(currentVisibleCells, eventsLoadSteps, visibleRows, rowsMap);
    currentVisibleCells = newVisibleCells;
    added.forEach(({ rowId, from }) => loadEvents(rowId, from));
    removed.forEach(({ rowId, from }) => cancelLoadEvents(rowId, from));
  });
  const reset = () => {
    unsubscribe();
    $data.off();
    $eventsLoadSteps.off();
  };
  return reset;
}
function createEvents($rowsStore, viewState, getEvents2, eventsLoadStepSize) {
  const dataTZOffset = getUserTimeZoneOffset();
  const { $viewRangeTime } = viewState;
  const [storage, resetStorage] = initStorage(dataTZOffset, eventsLoadStepSize);
  const [loadEvents, cancelLoadEvents, resetLoader] = initLoader(storage, getEvents2, eventsLoadStepSize);
  let activeLoaderReset = null;
  const rowsStoreUnsubscribe = $rowsStore.subscribe((rowsStore) => {
    if (activeLoaderReset) {
      activeLoaderReset();
    }
    activeLoaderReset = initVisibleEventsLoader(
      $viewRangeTime,
      rowsStore,
      loadEvents,
      cancelLoadEvents,
      dataTZOffset,
      eventsLoadStepSize
    );
  });
  const reset = () => {
    resetStorage();
    resetLoader();
    rowsStoreUnsubscribe();
    if (activeLoaderReset) {
      activeLoaderReset();
    }
  };
  const eventsStore = {
    storage
  };
  return [eventsStore, reset];
}
function initEvents($rowsStore, viewState, getEvents2, eventsLoadStepSize) {
  let [eventsStore, resetEventsStore] = createEvents($rowsStore, viewState, getEvents2, eventsLoadStepSize);
  const $eventsStore = atom(eventsStore);
  const reInitEvents = (newGetEvents, newEventsLoadStepSize) => {
    resetEventsStore();
    [eventsStore, resetEventsStore] = createEvents($rowsStore, viewState, newGetEvents, newEventsLoadStepSize);
    $eventsStore.set(eventsStore);
  };
  const reset = () => {
    resetEventsStore();
  };
  return [$eventsStore, reInitEvents, reset];
}
function initGridStepSize($timeState) {
  const $gridStepSize = computed($timeState, (timeState) => getGridStepSize(timeState.scale));
  const reset = () => {
    $gridStepSize.off();
  };
  return [$gridStepSize, reset];
}
function getRange(viewRange, gridStepSize, viewTimeZone) {
  const [viewStart, viewEnd] = viewRange;
  const start = fitTimeToStepSize(viewStart, gridStepSize, viewTimeZone.offset);
  const end = fitTimeToStepSize(viewEnd + gridStepSize, gridStepSize, viewTimeZone.offset);
  return [start, end];
}
function initGridSteps($viewRangeTime, $gridStepSize, $viewTimeZone) {
  const [$range, resetRange] = createAtom(
    getRange($viewRangeTime.get(), $gridStepSize.get(), $viewTimeZone.get())
  );
  const $data = computed([$viewRangeTime, $viewTimeZone], (viewRangeTime, viewTimeZone) => ({
    viewRangeTime,
    viewTimeZone
  }));
  const unsubscribeData = $data.listen(({ viewRangeTime, viewTimeZone }) => {
    const [oldStart, oldEnd] = $range.get();
    const [newStart, newEnd] = getRange(viewRangeTime, $gridStepSize.get(), viewTimeZone);
    if (newStart !== oldStart || newEnd !== oldEnd) {
      $range.set([newStart, newEnd]);
    }
  });
  const $gridSteps = computed(
    [$range, $gridStepSize],
    ([rangeStart, rangeEnd], gridStepSize) => {
      let gridStep2 = rangeStart;
      const gridSteps = [gridStep2];
      while (gridStep2 < rangeEnd) {
        gridStep2 += gridStepSize;
        gridSteps.push(gridStep2);
      }
      return gridSteps;
    }
  );
  const reset = () => {
    $gridSteps.off();
    resetRange();
    unsubscribeData();
  };
  return [$gridSteps, reset];
}
function initGridState(viewState, $viewTimeZone) {
  const { $timeState, $viewRangeTime } = viewState;
  const [$gridStepSize, resetGridStepSize] = initGridStepSize($timeState);
  const [$gridSteps, resetGridSteps] = initGridSteps($viewRangeTime, $gridStepSize, $viewTimeZone);
  const gridState = {
    $gridStepSize,
    $gridSteps
  };
  const reset = () => {
    resetGridStepSize();
    resetGridSteps();
  };
  return [gridState, reset];
}
var EVENT_MIN_WIDTH = 1;
function getHoveredEvent($dragging, $hoveredRow, $timelineSize, $rowsTop, $containerScrollTop, $rowsEvents, $timeState, $activeEvent, settings, coords) {
  const dragging2 = $dragging.get();
  if (dragging2) {
    return null;
  }
  const hoveredRows = $hoveredRow.get();
  const lastHoveredRow = hoveredRows && hoveredRows[hoveredRows.length - 1] || null;
  if (lastHoveredRow === null) {
    return null;
  }
  const { headerHeight, sidebarWidth, width, activeEventPanelWidth } = $timelineSize.get();
  if (coords.top < headerHeight || coords.left < sidebarWidth) {
    return null;
  }
  const activeEvent2 = $activeEvent.get();
  if (activeEvent2 && coords.left > width - activeEventPanelWidth) {
    return null;
  }
  const rowsTop = $rowsTop.get();
  const containerScrollTop = $containerScrollTop.get();
  const rowTop = rowsTop[lastHoveredRow] - containerScrollTop;
  const lineTop = rowTop + settings.rowPadding - settings.eventLineMargin;
  const mouseTop = coords.top - headerHeight;
  const diff = mouseTop - lineTop;
  if (diff < 0) {
    return null;
  }
  const lineStepSize = settings.eventLineHeight + settings.eventLineMargin;
  if (diff % lineStepSize < settings.eventLineMargin) {
    return null;
  }
  const lineIndex = Math.floor(diff / lineStepSize);
  const rowsEvents = $rowsEvents.get();
  const rowEvent = rowsEvents[lastHoveredRow];
  const events = rowEvent && rowEvent[lineIndex];
  if (!events || events.length === 0) {
    return null;
  }
  const timeState = $timeState.get();
  const mouseTime2 = timeState.start + coords.left * timeState.scale;
  const pixelTimeWidth = timeState.scale;
  let hoveredEvent2 = null;
  for (let i = 0; i < events.length; i++) {
    const event2 = events[i];
    const start = event2.start;
    const end = Math.max(event2.end, event2.start + pixelTimeWidth * 2);
    if (start < mouseTime2 && end > mouseTime2) {
      hoveredEvent2 = event2;
      break;
    }
  }
  if (hoveredEvent2) {
    const top = Math.round(
      rowTop + settings.rowPadding + lineIndex * (settings.eventLineHeight + settings.eventLineMargin)
    );
    const height = settings.eventLineHeight;
    const left = Math.round((hoveredEvent2.start - timeState.start) / timeState.scale - sidebarWidth);
    const width2 = Math.max(Math.round((hoveredEvent2.end - hoveredEvent2.start) / timeState.scale), EVENT_MIN_WIDTH);
    return { event: hoveredEvent2, rect: { top, left, height, width: width2 } };
  }
  return null;
}
function initHoveredEvent(viewState, $rowsStore, $hoveredRow, $rowsEvents, $settings) {
  const { $timelineSize, $containerScrollTop, $timeState, $mouseCoords, $mouseInside, $dragging, $activeEventVisible } = viewState;
  const [$hoveredEvent, resetHoveredEvent] = createAtom(null);
  const [$activeEvent, resetActiveEvent] = createAtom(null);
  let resetDataSubscribtion = null;
  const $data = computed([$rowsStore, $settings], (rowsStore, settings) => ({ rowsStore, settings }));
  const unsubscribeData = $data.subscribe(({ rowsStore, settings }) => {
    if (resetDataSubscribtion) {
      resetDataSubscribtion();
      resetDataSubscribtion = null;
    }
    if (!settings.showHoveredEventPopup && !settings.highlightHoveredEvent && !settings.renderActiveEvent) {
      return;
    }
    const { $rowsTop } = rowsStore;
    const unsubscribeMouseCoords = $mouseCoords.listen((coords) => {
      const hoveredEvent2 = getHoveredEvent(
        $dragging,
        $hoveredRow,
        $timelineSize,
        $rowsTop,
        $containerScrollTop,
        $rowsEvents,
        $timeState,
        $activeEvent,
        settings,
        coords
      );
      if ($hoveredEvent.get() !== hoveredEvent2) {
        $hoveredEvent.set(hoveredEvent2);
      }
    });
    const unsubscribeContainerScrollTop = $containerScrollTop.listen(() => $hoveredEvent.set(null));
    const unsubscribeTimeState = $timeState.listen(() => $hoveredEvent.set(null));
    const unsubscribeMouseInside = $mouseInside.listen((value2) => {
      if (!value2) {
        $hoveredEvent.set(null);
      }
    });
    resetDataSubscribtion = () => {
      unsubscribeMouseCoords();
      unsubscribeContainerScrollTop();
      unsubscribeTimeState();
      unsubscribeMouseInside();
    };
  });
  const onClick = () => {
    const dragging2 = $dragging.get();
    const settings = $settings.get();
    if (dragging2 || !settings.renderActiveEvent) {
      return;
    }
    const { width, activeEventPanelWidth } = $timelineSize.get();
    const { left } = $mouseCoords.get();
    const activeEvent2 = $activeEvent.get();
    const hoveredEvent2 = $hoveredEvent.get();
    if (!hoveredEvent2) {
      if (activeEvent2) {
        if (left < width - activeEventPanelWidth) {
          $activeEvent.set(null);
        }
      }
      return;
    }
    $activeEvent.set(hoveredEvent2.event);
  };
  const unsubscribeActiveEventMouseInside = $mouseInside.subscribe((isMouseInside) => {
    if (isMouseInside) {
      document.addEventListener("click", onClick);
    } else {
      document.removeEventListener("click", onClick);
    }
  });
  const unsubscribeActiveEvent = $activeEvent.subscribe((activeEvent2) => $activeEventVisible.set(Boolean(activeEvent2)));
  const reset = () => {
    unsubscribeData();
    resetHoveredEvent();
    resetActiveEvent();
    unsubscribeActiveEvent();
    unsubscribeActiveEventMouseInside();
    if (resetDataSubscribtion) {
      resetDataSubscribtion();
    }
  };
  return [$hoveredEvent, $activeEvent, reset];
}
function getHovered(rows, rowsTop, mouseTop, rowsHeight, rowsMap) {
  let hovered2 = null;
  for (let i = 0; i < rows.length; i++) {
    const rowId = rows[i];
    const rowTop = rowsTop[rowId];
    if (mouseTop > rowTop) {
      const rowHeight = rowsHeight[rowId];
      if (mouseTop < rowTop + rowHeight) {
        hovered2 = [rowId];
        break;
      }
      const { children } = rowsMap[rowId];
      if (children) {
        const childIds = children.map(({ id }) => id);
        const childHovered = getHovered(childIds, rowsTop, mouseTop, rowsHeight, rowsMap);
        if (childHovered) {
          hovered2 = [rowId, ...childHovered];
        }
      }
    }
  }
  return hovered2;
}
function hoveredRowChanged(prev, next) {
  if (prev === null && next === null) {
    return false;
  }
  if (prev === null || next === null) {
    return true;
  }
  if (prev.length !== next.length) {
    return true;
  }
  for (let i = 0; i < prev.length; i++) {
    if (prev[i] !== next[i]) {
      return true;
    }
  }
  return false;
}
function initHoveredRow(viewState, $rowsStore) {
  const { $timelineSize, $containerScrollTop, $timeState, $mouseCoords, $mouseInside } = viewState;
  const [$hoveredRow, resetHoveredRow] = createAtom(null);
  let resetRowsStoreSubscribtion = null;
  const setHoveredRow = (next) => {
    const curr = $hoveredRow.get();
    if (hoveredRowChanged(curr, next)) {
      $hoveredRow.set(next);
    }
  };
  const unsubscribeContainerScrollTop = $containerScrollTop.listen(() => setHoveredRow(null));
  const unsubscribeTimeState = $timeState.listen(() => setHoveredRow(null));
  const unsubscribeMouseInside = $mouseInside.listen((value2) => {
    if (!value2) {
      setHoveredRow(null);
    }
  });
  const unsubscribe = $rowsStore.subscribe((rowsStore) => {
    if (resetRowsStoreSubscribtion) {
      resetRowsStoreSubscribtion();
    }
    const { $visibleRows, $rowsTop, $rowsHeight, $rowsMap } = rowsStore;
    const unsubscribeMouseCoords = $mouseCoords.listen((coords) => {
      const { headerHeight } = $timelineSize.get();
      const visibleRows = $visibleRows.get();
      const rowsTop = $rowsTop.get();
      const rowsHeight = $rowsHeight.get();
      const rowsMap = $rowsMap.get();
      const containerScrollTop = $containerScrollTop.get();
      const mouseTop = coords.top - headerHeight + containerScrollTop;
      const hovered2 = getHovered(visibleRows, rowsTop, mouseTop, rowsHeight, rowsMap);
      setHoveredRow(hovered2);
    });
    resetRowsStoreSubscribtion = () => {
      unsubscribeMouseCoords();
    };
  });
  const reset = () => {
    unsubscribe();
    unsubscribeContainerScrollTop();
    unsubscribeTimeState();
    unsubscribeMouseInside();
    resetHoveredRow();
    if (resetRowsStoreSubscribtion) {
      resetRowsStoreSubscribtion();
    }
  };
  return [$hoveredRow, reset];
}
function initRenderedEvents() {
  const $renderedEvents = atom([]);
  const reset = () => {
    $renderedEvents.off();
  };
  return [$renderedEvents, reset];
}
function updateRowTop(rowId, rowsTop, rowsHeight, rowsMap, currentTop, settings) {
  rowsTop[rowId] = currentTop;
  const { children } = rowsMap[rowId];
  const rowHeight = rowsHeight[rowId];
  let nextTop = currentTop + rowHeight;
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const childRow = children[i];
      nextTop = updateRowTop(childRow.id, rowsTop, rowsHeight, rowsMap, nextTop);
    }
  }
  return nextTop;
}
function initHeightController(containerNode, $timelineSize, $rowsIds, $rowsHeight, $rowsTop, $containerHeight, $rowsLoading, $settings, $rowsMap) {
  const [$containerRowsHeight, resetContainerRowsHeight] = createAtom(0);
  const rowsAnimationController = /* @__PURE__ */ new Map();
  let updateRowsHeightPlanned = false;
  let stopped = false;
  const updateRowsTop = () => {
    const { headerHeight } = $timelineSize.get();
    const ids = $rowsIds.get();
    const rowsHeight = $rowsHeight.get();
    const rowsTop = $rowsTop.get();
    const settings = $settings.get();
    const rowsMap = $rowsMap.get();
    const newRowsTop = { ...rowsTop };
    let top = settings.dataViewPadding;
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i];
      top = updateRowTop(id, newRowsTop, rowsHeight, rowsMap, top);
    }
    $rowsTop.set(newRowsTop);
    $containerRowsHeight.set(top + headerHeight + settings.dataViewPadding);
  };
  const requestUpdateRowsTop = () => {
    if (updateRowsHeightPlanned) {
      return;
    }
    updateRowsHeightPlanned = true;
    requestAnimationFrame(() => {
      if (stopped) {
        return;
      }
      updateRowsTop();
      updateRowsHeightPlanned = false;
    });
  };
  const updateContainerHeight = () => {
    let height = $containerRowsHeight.get();
    const rowsLoading = $rowsLoading.get();
    if (rowsLoading) {
      height += SIDEBAR_LOADING_HEIGHT;
    }
    containerNode.style.height = `${height}px`;
    $containerHeight.set(height);
  };
  const unsubscribeIds = $rowsIds.listen(updateRowsTop);
  const unsubscribeSettings = $settings.listen(updateRowsTop);
  const unsubscribeSize = $timelineSize.listen(requestUpdateRowsTop);
  const unsubscribeLoading = $rowsLoading.listen(updateContainerHeight);
  const unsubscribeContainer = $containerRowsHeight.listen(updateContainerHeight);
  const setRowHeight = (rowId, height) => {
    let animationController = rowsAnimationController.get(rowId);
    if (!animationController) {
      const rowHeight = $rowsHeight.get()[rowId];
      animationController = initAnimationController(rowHeight, (value2) => {
        $rowsHeight.setKey(rowId, Math.round(value2));
        requestUpdateRowsTop();
      });
      rowsAnimationController.set(rowId, animationController);
    }
    const settings = $settings.get();
    animationController.move(height, settings.eventLineHeight * 10);
  };
  const reset = () => {
    unsubscribeIds();
    unsubscribeSettings();
    unsubscribeSize();
    unsubscribeLoading();
    unsubscribeContainer();
    resetContainerRowsHeight();
    Array.from(rowsAnimationController).forEach(([rowId, animationController]) => {
      rowsAnimationController.delete(rowId);
      animationController.reset();
    });
    stopped = true;
  };
  return [setRowHeight, reset];
}
var COUNT_PER_PAGE = 10;
var LOAD_TRESHOLD = 100;
function addRow(rowItem, rowsHeight, rowsMap, rowsCrossEventsStrategy, rowsNestedLevel, rowsExpanded, settings, nestedLevel = 0) {
  const { rowPadding, eventLineHeight, crossEventsStrategy: crossEventsStrategy2 } = settings;
  const { children } = rowItem;
  rowsMap[rowItem.id] = rowItem;
  rowsCrossEventsStrategy[rowItem.id] = crossEventsStrategy2;
  rowsNestedLevel[rowItem.id] = nestedLevel;
  rowsExpanded[rowItem.id] = rowItem.defaultExpanded || false;
  let height = eventLineHeight + 2 * rowPadding;
  if (children && children.length > 0) {
    height += rowPadding;
    for (let i = 0; i < children.length; i++) {
      const childRowItem = children[i];
      height += addRow(
        childRowItem,
        rowsHeight,
        rowsMap,
        rowsCrossEventsStrategy,
        rowsNestedLevel,
        rowsExpanded,
        settings,
        nestedLevel + 1
      );
    }
  }
  rowsHeight[rowItem.id] = height;
  return height;
}
function pushNewRows(page, $rowsCrossEventsStrategy, $settings, $rowsIds, $rowsHeight, $rowsMap, $rowsNestedLevel, $rowsExpanded) {
  const settings = $settings.get();
  const currIds = $rowsIds.get();
  const currRowsHeight = $rowsHeight.get();
  const currCrossEventsStrategy = $rowsCrossEventsStrategy.get();
  const currRowsMap = $rowsMap.get();
  const currRowsNestedLevel = $rowsNestedLevel.get();
  const currRowsExpanded = $rowsExpanded.get();
  const newIds = currIds.slice(0, page.offset);
  const newRowsHeight = { ...currRowsHeight };
  const newCrossEventsStrategy = { ...currCrossEventsStrategy };
  const newRowsMap = { ...currRowsMap };
  const newRowsNestedLevel = { ...currRowsNestedLevel };
  const newRowsExpanded = { ...currRowsExpanded };
  for (let i = 0; i < page.data.length; i++) {
    const rowItem = page.data[i];
    newIds.push(rowItem.id);
    addRow(rowItem, newRowsHeight, newRowsMap, newCrossEventsStrategy, newRowsNestedLevel, newRowsExpanded, settings);
  }
  $rowsMap.set(newRowsMap);
  $rowsHeight.set(newRowsHeight);
  $rowsCrossEventsStrategy.set(newCrossEventsStrategy);
  $rowsNestedLevel.set(newRowsNestedLevel);
  $rowsExpanded.set(newRowsExpanded);
  $rowsIds.set(newIds);
}
function initLoadController(scrollableNode, $timelineSize, $containerScrollTop, $rowsIds, $rowsMap, $rowsHeight, $rowsCrossEventsStrategy, $rowsLoading, $settings, $containerHeight, $rowsNestedLevel, $rowsExpanded, getRows) {
  let stopped = false;
  let totalCount = 1;
  let loadedCount = 0;
  let needLoadNext = false;
  let loading2 = false;
  const addRowsPage = (page) => {
    totalCount = page.totalCount;
    loadedCount = page.offset + page.count;
    pushNewRows(
      page,
      $rowsCrossEventsStrategy,
      $settings,
      $rowsIds,
      $rowsHeight,
      $rowsMap,
      $rowsNestedLevel,
      $rowsExpanded
    );
  };
  const load = async () => {
    if (stopped || loadedCount === totalCount) {
      needLoadNext = false;
      $rowsLoading.set(false);
      loading2 = false;
      return;
    }
    if (loading2) {
      needLoadNext = true;
      return;
    }
    $rowsLoading.set(true);
    loading2 = true;
    const page = await getRows({
      offset: loadedCount,
      count: COUNT_PER_PAGE
    });
    if (stopped) {
      return;
    }
    addRowsPage(page);
    loading2 = false;
    if (needLoadNext) {
      needLoadNext = false;
      load();
    } else {
      $rowsLoading.set(false);
      requestLoad();
    }
  };
  const loadIfNeed = () => {
    if (stopped) {
      return;
    }
    const bottomSpace = scrollableNode.scrollHeight - scrollableNode.offsetHeight - scrollableNode.scrollTop;
    if (bottomSpace < LOAD_TRESHOLD) {
      load();
    }
  };
  let loadPlanned = false;
  const requestLoad = () => {
    if (loadPlanned) {
      return;
    }
    loadPlanned = true;
    requestAnimationFrame(() => {
      loadIfNeed();
      loadPlanned = false;
    });
  };
  const unsubscribeContainer = $containerScrollTop.listen(requestLoad);
  const unsubscribeTimelineSize = $timelineSize.listen(requestLoad);
  const unsubscribeContainerHeight = $containerHeight.listen(requestLoad);
  const reset = () => {
    stopped = true;
    unsubscribeContainer();
    unsubscribeTimelineSize();
    unsubscribeContainerHeight();
  };
  load();
  return reset;
}
function initRowsCrossEventsStrategy($settings) {
  const [$rowsCrossEventsStrategy, resetCrossEventsStrategy] = createMapStore();
  let { crossEventsStrategy: crossEventsStrategy2 } = $settings.get();
  $settings.listen((settings) => {
    if (settings.crossEventsStrategy !== crossEventsStrategy2) {
      crossEventsStrategy2 = settings.crossEventsStrategy;
      const rowsCrossEventsStrategy = $rowsCrossEventsStrategy.get();
      const newCrossEventsStrategy = {};
      for (const key in rowsCrossEventsStrategy) {
        newCrossEventsStrategy[key] = crossEventsStrategy2;
      }
      $rowsCrossEventsStrategy.set(newCrossEventsStrategy);
    }
  });
  return [$rowsCrossEventsStrategy, resetCrossEventsStrategy];
}
function rowsChanged(currRows, newRows) {
  if (currRows.length !== newRows.length) {
    return true;
  }
  for (let i = 0; i < currRows.length; i++) {
    if (currRows[i] !== newRows[i]) {
      return true;
    }
  }
  return false;
}
function initVisibleRows($rowsIds, $timelineSize, $containerScrollTop, $rowsTop, $rowsHeight, $rowsMap) {
  const [$visibleRows, resetVisibleRows] = createAtom([]);
  const $data = computed(
    [$rowsIds, $timelineSize, $containerScrollTop, $rowsTop, $rowsHeight, $rowsMap],
    (rowsIds, timelineSize, containerScrollTop, rowsTop, rowsHeight, rowsMap) => ({
      rowsIds,
      timelineSize,
      containerScrollTop,
      rowsTop,
      rowsHeight,
      rowsMap
    })
  );
  const unsubscribe = $data.subscribe(({ rowsIds, timelineSize, containerScrollTop, rowsTop, rowsHeight, rowsMap }) => {
    const visibleRows = [];
    const { dataHeight } = timelineSize;
    const viewTop = containerScrollTop;
    const viewBottom = viewTop + dataHeight;
    for (let i = 0; i < rowsIds.length; i++) {
      const id = rowsIds[i];
      const rowTop = rowsTop[id];
      const rowHeight = getRowHeightWithChildren(id, rowsHeight, rowsMap);
      const rowBottom = rowTop + rowHeight;
      if (rowTop > viewBottom) {
        break;
      }
      if (rowBottom >= viewTop) {
        visibleRows.push(id);
      }
    }
    const currVisibleRows = $visibleRows.get();
    if (rowsChanged(currVisibleRows, visibleRows)) {
      $visibleRows.set(visibleRows);
    }
  });
  const reset = () => {
    unsubscribe();
    $data.off();
    resetVisibleRows();
  };
  return [$visibleRows, reset];
}
function createRows(containerNode, scrollableNode, $timelineSize, $containerScrollTop, $settings, getRows) {
  const [$rowsIds, resetRowsIds] = createAtom([]);
  const [$rowsMap, resetRowsMap] = createMapStore();
  const [$rowsCrossEventsStrategy, resetRowsCrossEventsStrategy] = initRowsCrossEventsStrategy($settings);
  const [$rowsLoading, resetRowsLoading] = createAtom(false);
  const [$rowsHeight, resetRowsHeight] = createMapStore();
  const [$rowsNestedLevel, resetRowsNestedLevel] = createMapStore();
  const [$rowsExpanded, resetRowsExpanded] = createMapStore();
  const [$rowsTop, resetRowsTop] = createMapStore();
  const [$containerHeight, resetContainerHeight] = createAtom(0);
  const [$visibleRows, resetVisibleRows] = initVisibleRows(
    $rowsIds,
    $timelineSize,
    $containerScrollTop,
    $rowsTop,
    $rowsHeight,
    $rowsMap
  );
  const resetLoadController = initLoadController(
    scrollableNode,
    $timelineSize,
    $containerScrollTop,
    $rowsIds,
    $rowsMap,
    $rowsHeight,
    $rowsCrossEventsStrategy,
    $rowsLoading,
    $settings,
    $containerHeight,
    $rowsNestedLevel,
    $rowsExpanded,
    getRows
  );
  const [setRowHeight, resetHeightController] = initHeightController(
    containerNode,
    $timelineSize,
    $rowsIds,
    $rowsHeight,
    $rowsTop,
    $containerHeight,
    $rowsLoading,
    $settings,
    $rowsMap
  );
  const reset = () => {
    resetRowsIds();
    resetRowsMap();
    resetRowsLoading();
    resetLoadController();
    resetRowsHeight();
    resetHeightController();
    resetRowsTop();
    resetContainerHeight();
    resetVisibleRows();
    resetRowsCrossEventsStrategy();
    resetRowsNestedLevel();
    resetRowsExpanded();
  };
  const rowsStore = {
    $rowsIds,
    $rowsMap,
    $rowsCrossEventsStrategy,
    $rowsHeight,
    $rowsTop,
    $rowsLoading,
    $containerHeight,
    $visibleRows,
    $rowsNestedLevel,
    $rowsExpanded,
    setRowHeight
  };
  return [rowsStore, reset];
}
function initRows(containerNode, scrollableNode, viewState, $settings, getRows) {
  let [rowsStore, resetRowsStore] = createRows(
    containerNode,
    scrollableNode,
    viewState.$timelineSize,
    viewState.$containerScrollTop,
    $settings,
    getRows
  );
  const $rowsStore = atom(rowsStore);
  const reInitRows = (newGetRows) => {
    resetRowsStore();
    scrollableNode.scrollTop = 0;
    [rowsStore, resetRowsStore] = createRows(
      containerNode,
      scrollableNode,
      viewState.$timelineSize,
      viewState.$containerScrollTop,
      $settings,
      newGetRows
    );
    $rowsStore.set(rowsStore);
  };
  const reset = () => {
    resetRowsStore();
  };
  return [$rowsStore, reInitRows, reset];
}
function updateEventsLines(eventsDiff, prevLines) {
  let lines = [];
  const { addedEnd, addedStart, removedEnd, removedStart } = eventsDiff;
  const removedEndIds = new Set(removedEnd.map(({ id }) => id));
  const removedStartIds = new Set(removedStart.map(({ id }) => id));
  for (let i = 0; i < prevLines.length; i++) {
    const line = prevLines[i];
    let startIndex = 0;
    while (startIndex < line.length && removedStartIds.has(line[startIndex].id)) {
      startIndex++;
    }
    let endIndex = line.length - 1;
    while (endIndex >= 0 && removedEndIds.has(line[endIndex].id)) {
      endIndex--;
    }
    lines.push(line.slice(startIndex, endIndex + 1));
  }
  lines = lines.filter((line) => line.length > 0);
  const linesEnds = lines.map((line) => {
    const lastEvent = line[line.length - 1];
    return lastEvent.end;
  });
  for (let i = 0; i < addedEnd.length; i++) {
    const event2 = addedEnd[i];
    let pushed = false;
    for (let j = 0; j < lines.length; j++) {
      const line = lines[j];
      if (linesEnds[j] <= event2.start) {
        line.push(event2);
        linesEnds[j] = event2.end;
        pushed = true;
        break;
      }
    }
    if (!pushed) {
      const newLine = [event2];
      lines.push(newLine);
      linesEnds.push(event2.end);
    }
  }
  const addedStartSorted = addedStart.sort((event1, event2) => event2.end - event1.end);
  const linesStarts = lines.map((line) => {
    const firstEvent = line[0];
    return firstEvent.start;
  });
  for (let i = 0; i < addedStartSorted.length; i++) {
    const event2 = addedStartSorted[i];
    let pushed = false;
    for (let j = 0; j < lines.length; j++) {
      const line = lines[j];
      if (linesStarts[j] >= event2.end) {
        line.unshift(event2);
        linesStarts[j] = event2.start;
        pushed = true;
        break;
      }
    }
    if (!pushed) {
      const newLine = [event2];
      lines.push(newLine);
      linesStarts.push(event2.start);
    }
  }
  return lines;
}
function splitEventsToLines(events) {
  if (!events || events.length === 0) {
    return [];
  }
  const [firstEvent] = events;
  const lines = [[firstEvent]];
  const linesEnds = [firstEvent.end];
  for (let i = 1; i < events.length; i++) {
    const event2 = events[i];
    let pushed = false;
    for (let j = 0; j < lines.length; j++) {
      const line = lines[j];
      if (linesEnds[j] <= event2.start) {
        line.push(event2);
        linesEnds[j] = event2.end;
        pushed = true;
        break;
      }
    }
    if (!pushed) {
      const newLine = [event2];
      lines.push(newLine);
      linesEnds.push(event2.end);
    }
  }
  return lines;
}
function getEventsLines(events, crossEventsStrategy2, cache) {
  if (crossEventsStrategy2 === "overlay-crossed-events") {
    return [events];
  }
  if (!cache || cache.crossEventsStrategy !== crossEventsStrategy2) {
    return splitEventsToLines(events);
  }
  const eventsDiff = getEventsDiff(cache.events, events);
  if (!eventsDiff) {
    return splitEventsToLines(events);
  }
  return updateEventsLines(eventsDiff, cache.lines);
}
function getEvents(rowsEventsCache, storage, rowId, parentIds, range, rowsExpanded, rowsMap, rowsCrossEventsStrategy) {
  const [start, end] = range;
  if (parentIds.some((id) => !rowsExpanded[id])) {
    return [];
  }
  const rowsIds = getNestedCoolapsedRowsIds(rowId, rowsMap, rowsExpanded);
  const movedStart = Math.round(start - (end - start) / 10);
  const rowsEvents = rowsIds.map((id) => storage.getEvents(id, [movedStart, end]));
  const events = joinSortedEvents(rowsEvents);
  const crossEventsStrategy2 = rowsCrossEventsStrategy[rowId];
  const cache = rowsEventsCache.get(rowId);
  const lines = getEventsLines(events, crossEventsStrategy2, cache);
  rowsEventsCache.set(rowId, { events, lines, crossEventsStrategy: crossEventsStrategy2 });
  return lines;
}
function getRowsDiff(rows, rowsIds) {
  const added = [];
  const rowsSet = new Set(rows);
  for (let i = 0; i < rowsIds.length; i++) {
    const id = rowsIds[i];
    if (rowsSet.has(id)) {
      rowsSet.delete(id);
    } else {
      added.push(id);
    }
  }
  const removed = Array.from(rowsSet);
  return [added, removed];
}
function initRowsEvents(viewState, $rowsStore, $eventsStore) {
  const { $viewRangeTime } = viewState;
  const visibleRowsState = /* @__PURE__ */ new Set();
  const activeRowsState = /* @__PURE__ */ new Map();
  const rowsEventsCache = /* @__PURE__ */ new Map();
  const [$rowsEvents, resetRowsEvents] = createAtom({});
  const $dataProvider = computed([$rowsStore, $eventsStore], (rowsStore, eventsStore) => {
    const { $visibleRows, $rowsMap, $rowsExpanded, $rowsCrossEventsStrategy } = rowsStore;
    const { storage } = eventsStore;
    return { $visibleRows, $rowsMap, $rowsExpanded, $rowsCrossEventsStrategy, storage };
  });
  let unsubscribeVisibleRows = null;
  let unsubscribeViewRangeTime = null;
  let unsubscribeRowsExpanded = null;
  let unsubscribeCrossEventsStrategy = null;
  let unsubscribeStorage = null;
  const unsubscribe = $dataProvider.subscribe(
    ({ $visibleRows, $rowsMap, $rowsExpanded, $rowsCrossEventsStrategy, storage }) => {
      let hash = "";
      if (unsubscribeVisibleRows) {
        unsubscribeVisibleRows();
      }
      if (unsubscribeViewRangeTime) {
        unsubscribeViewRangeTime();
      }
      if (unsubscribeRowsExpanded) {
        unsubscribeRowsExpanded();
      }
      if (unsubscribeCrossEventsStrategy) {
        unsubscribeCrossEventsStrategy();
      }
      if (unsubscribeStorage) {
        unsubscribeStorage();
      }
      unsubscribeStorage = () => {
        Array.from(activeRowsState).forEach(([rowId, row2]) => {
          activeRowsState.delete(rowId);
          row2.reset();
        });
        $rowsEvents.set({});
        activeRowsState.clear();
        visibleRowsState.clear();
        rowsEventsCache.clear();
      };
      const updateRowsEvents = (rowsIds) => {
        const range = $viewRangeTime.get();
        const rowsExpanded = $rowsExpanded.get();
        const rowsCrossEventsStrategy = $rowsCrossEventsStrategy.get();
        const rowsMap = $rowsMap.get();
        const currRowsEvents = $rowsEvents.get();
        const rowsEvents = {};
        activeRowsState.forEach((row2) => {
          if (rowsIds && !rowsIds.includes(row2.rowId)) {
            rowsEvents[row2.rowId] = currRowsEvents[row2.rowId];
          } else {
            rowsEvents[row2.rowId] = getEvents(
              rowsEventsCache,
              storage,
              row2.rowId,
              row2.parentsIds,
              range,
              rowsExpanded,
              rowsMap,
              rowsCrossEventsStrategy
              // currRowsEvents[row.rowId] || null,
            );
          }
        });
        $rowsEvents.set(rowsEvents);
      };
      unsubscribeViewRangeTime = $viewRangeTime.subscribe(() => updateRowsEvents());
      unsubscribeRowsExpanded = $rowsExpanded.subscribe(() => updateRowsEvents());
      unsubscribeCrossEventsStrategy = $rowsCrossEventsStrategy.subscribe(() => updateRowsEvents());
      const addRow2 = (rowId, rowsEvents, rowsMap, rowsExpanded, parentsIds = []) => {
        const parentsStack = [...parentsIds, rowId];
        const unsubscribe2 = storage.subscribe(rowId, () => {
          updateRowsEvents(parentsStack);
        });
        const row2 = {
          reset: unsubscribe2,
          rowId,
          parentsIds
        };
        activeRowsState.set(rowId, row2);
        rowsEvents[rowId] = getEvents(
          rowsEventsCache,
          storage,
          rowId,
          parentsIds,
          $viewRangeTime.get(),
          rowsExpanded,
          rowsMap,
          $rowsCrossEventsStrategy.get()
          // null,
        );
        const { children } = rowsMap[rowId];
        if (children) {
          for (let i = 0; i < children.length; i++) {
            const childRow = children[i];
            addRow2(childRow.id, rowsEvents, rowsMap, rowsExpanded, parentsStack);
          }
        }
      };
      const removeRow = (rowId, rowsEvents, rowsMap) => {
        const row2 = activeRowsState.get(rowId);
        rowsEventsCache.delete(rowId);
        if (row2) {
          row2.reset();
          activeRowsState.delete(rowId);
        }
        delete rowsEvents[rowId];
        const { children } = rowsMap[rowId];
        if (children) {
          for (let i = 0; i < children.length; i++) {
            const childRow = children[i];
            removeRow(childRow.id, rowsEvents, rowsMap);
          }
        }
      };
      unsubscribeVisibleRows = $visibleRows.subscribe((visibleRowsIds) => {
        const rowsMap = $rowsMap.get();
        const rowsExpanded = $rowsExpanded.get();
        const newHash = visibleRowsIds.join("-");
        if (hash === newHash) {
          return;
        }
        hash = newHash;
        const [added, removed] = getRowsDiff(visibleRowsState, visibleRowsIds);
        const newRowsEvents = { ...$rowsEvents.get() };
        for (let i = 0; i < added.length; i++) {
          const id = added[i];
          visibleRowsState.add(id);
          addRow2(id, newRowsEvents, rowsMap, rowsExpanded);
        }
        for (let i = 0; i < removed.length; i++) {
          const id = removed[i];
          visibleRowsState.delete(id);
          removeRow(id, newRowsEvents, rowsMap);
        }
        $rowsEvents.set(newRowsEvents);
      });
    }
  );
  const reset = () => {
    unsubscribe();
    if (unsubscribeVisibleRows) {
      unsubscribeVisibleRows();
    }
    if (unsubscribeViewRangeTime) {
      unsubscribeViewRangeTime();
    }
    if (unsubscribeRowsExpanded) {
      unsubscribeRowsExpanded();
    }
    if (unsubscribeCrossEventsStrategy) {
      unsubscribeCrossEventsStrategy();
    }
    if (unsubscribeStorage) {
      unsubscribeStorage();
    }
    resetRowsEvents();
  };
  return [$rowsEvents, reset];
}
function updateRowHeight(rowId, setRowHeight, rowsHeight, rowsCrossEventsStrategy, settings, rowsEvents, rowsMap, rowsExpanded, visible2 = true, isLastChild = false) {
  const crossEventsStrategy2 = rowsCrossEventsStrategy[rowId];
  let height = 0;
  const { children } = rowsMap[rowId];
  const expanded2 = rowsExpanded[rowId];
  if (visible2) {
    height += settings.eventLineHeight + 2 * settings.rowPadding;
    if (crossEventsStrategy2 === "split-crossed-events") {
      const eventsLines = rowsEvents[rowId];
      if (eventsLines && eventsLines.length > 1) {
        height += (eventsLines.length - 1) * (settings.eventLineHeight + settings.eventLineMargin);
      }
    }
    if (isLastChild && (!children || !expanded2)) {
      height += settings.rowPadding;
    }
  }
  if (children && children.length > 0) {
    for (let i = 0; i < children.length; i++) {
      const childItem = children[i];
      const isLast = i === children.length - 1;
      updateRowHeight(
        childItem.id,
        setRowHeight,
        rowsHeight,
        rowsCrossEventsStrategy,
        settings,
        rowsEvents,
        rowsMap,
        rowsExpanded,
        visible2 && expanded2,
        isLast
      );
    }
  }
  if (rowsHeight[rowId] !== height) {
    setRowHeight(rowId, height);
  }
  return height;
}
function initRowsHeightController($rowsStore, $rowsEvents, $settings) {
  let resetRowsHeightController = null;
  const unsubscribe = $rowsStore.subscribe((rowsStore) => {
    if (resetRowsHeightController) {
      resetRowsHeightController();
    }
    const { $visibleRows, $rowsHeight, $rowsCrossEventsStrategy, $rowsMap, $rowsExpanded, setRowHeight } = rowsStore;
    const $data = computed(
      [$visibleRows, $rowsCrossEventsStrategy, $rowsEvents, $rowsExpanded, $settings],
      (visibleRows, rowsCrossEventsStrategy, rowsEvents, rowsExpanded, settings) => ({
        visibleRows,
        rowsCrossEventsStrategy,
        rowsEvents,
        rowsExpanded,
        settings
      })
    );
    const unsubscribeData = $data.subscribe(
      ({ visibleRows, rowsCrossEventsStrategy, rowsEvents, rowsExpanded, settings }) => {
        const rowsMap = $rowsMap.get();
        const rowsHeight = $rowsHeight.get();
        for (let i = 0; i < visibleRows.length; i++) {
          const rowId = visibleRows[i];
          updateRowHeight(
            rowId,
            setRowHeight,
            rowsHeight,
            rowsCrossEventsStrategy,
            settings,
            rowsEvents,
            rowsMap,
            rowsExpanded
          );
        }
      }
    );
    resetRowsHeightController = () => {
      unsubscribeData();
      $data.off();
    };
  });
  const reset = () => {
    unsubscribe();
    if (resetRowsHeightController) {
      resetRowsHeightController();
    }
  };
  return reset;
}
var DEFAULT_SETTINGS = {
  canChangeCrossEventsStrategy: false,
  crossEventsStrategy: "split-crossed-events",
  sidebarWidth: "auto",
  activeEventPanelWidth: "auto",
  showCurrentTime: true,
  showMouseTime: true,
  showHoveredEventPopup: true,
  highlightHoveredEvent: true,
  showTimezoneInfo: true,
  showScaleController: true,
  showSidebar: true,
  headerHeight: DEFAULT_HEADER_HEIGHT,
  dataViewPadding: DEFAULT_DATA_VIEW_PADDING,
  rowPadding: DEFAULT_ROW_PADDING,
  eventLineHeight: DEFAULT_EVENT_LINE_HEIGHT,
  eventLineMargin: DEFAULT_EVENT_LINE_MARGIN,
  renderGridLines: true,
  eventBorderRadius: 0,
  eventContentMinWidth: DEFAULT_EVENT_CONTENT_MIN_WIDTH,
  highlightHoveredRow: false,
  renderEventContent: null,
  renderActiveEvent: null,
  renderEventPopupContent: null,
  renderSidebarRowContent: null
};
var settingsKeys = Object.keys(DEFAULT_SETTINGS);
function getValueCheckers() {
  return {
    canChangeCrossEventsStrategy: (value2) => typeof value2 === "boolean",
    crossEventsStrategy: (value2) => value2 === "overlay-crossed-events" || value2 === "split-crossed-events",
    showCurrentTime: (value2) => typeof value2 === "boolean",
    showMouseTime: (value2) => typeof value2 === "boolean",
    showHoveredEventPopup: (value2) => typeof value2 === "boolean",
    highlightHoveredEvent: (value2) => typeof value2 === "boolean",
    showTimezoneInfo: (value2) => typeof value2 === "boolean",
    showScaleController: (value2) => typeof value2 === "boolean",
    showSidebar: (value2) => typeof value2 === "boolean",
    sidebarWidth: (value2) => typeof value2 === "number" || value2 === "auto",
    activeEventPanelWidth: (value2) => typeof value2 === "number" || value2 === "auto",
    headerHeight: (value2) => typeof value2 === "number",
    dataViewPadding: (value2) => typeof value2 === "number",
    rowPadding: (value2) => typeof value2 === "number",
    eventLineHeight: (value2) => typeof value2 === "number",
    eventLineMargin: (value2) => typeof value2 === "number",
    eventBorderRadius: (value2) => typeof value2 === "number",
    eventContentMinWidth: (value2) => typeof value2 === "number",
    highlightHoveredRow: (value2) => typeof value2 === "boolean",
    renderGridLines: (value2) => typeof value2 === "boolean",
    renderEventContent: (value2) => typeof value2 === "function",
    renderActiveEvent: (value2) => typeof value2 === "function",
    renderEventPopupContent: (value2) => typeof value2 === "function",
    renderSidebarRowContent: (value2) => typeof value2 === "function"
  };
}
function getSettingsValue(valueCheckers, key, ...settings) {
  const checkValue = valueCheckers[key];
  for (let i = 0; i < settings.length; i++) {
    const value2 = settings[i][key];
    if (checkValue(value2)) {
      return value2;
    }
  }
  return DEFAULT_SETTINGS[key];
}
function mergeSettings(...settings) {
  const valueCheckers = getValueCheckers();
  return settingsKeys.reduce((acc, key) => {
    acc[key] = getSettingsValue(valueCheckers, key, ...settings);
    return acc;
  }, {});
}
function initSettings(defaultSettings) {
  const [$settings, resetSettings] = createAtom(mergeSettings(defaultSettings || {}));
  const setSettings = (settings) => {
    $settings.set(mergeSettings(settings));
  };
  return [$settings, setSettings, resetSettings];
}
function validateTimeZoneName(timeZoneName) {
  if (!timeZoneName) {
    return null;
  }
  if (SUPPORTED_TIME_ZONES.includes(timeZoneName)) {
    return timeZoneName;
  }
  console.error(`Unsupported time zone ${timeZoneName}, local time zone will be used: ${CURRENT_TIME_ZONE}`);
  return null;
}
function initViewTimeZone(viewState, defaultViewTimeZoneName) {
  const { $viewRangeTime } = viewState;
  let viewTimeZoneName = validateTimeZoneName(defaultViewTimeZoneName);
  const getOffset = (range) => {
    const [start, end] = range;
    const middle = Math.round((start + end) / 2);
    return getTimezoneOffset(middle, viewTimeZoneName);
  };
  const [$viewTimeZone, resetViewTimeZone] = createAtom({
    name: viewTimeZoneName || CURRENT_TIME_ZONE,
    offset: getOffset($viewRangeTime.get())
  });
  const unsubscribe = $viewRangeTime.subscribe((range) => {
    const newOffset = getOffset(range);
    const { offset } = $viewTimeZone.get();
    if (offset !== newOffset) {
      $viewTimeZone.set({
        name: viewTimeZoneName || CURRENT_TIME_ZONE,
        offset: newOffset
      });
    }
  });
  const setViewTimeZone = (newViewTimeZoneName) => {
    viewTimeZoneName = validateTimeZoneName(newViewTimeZoneName);
    $viewTimeZone.set({
      name: viewTimeZoneName || CURRENT_TIME_ZONE,
      offset: getOffset($viewRangeTime.get())
    });
  };
  const reset = () => {
    unsubscribe();
    resetViewTimeZone();
  };
  return [$viewTimeZone, setViewTimeZone, reset];
}
function initBoundingRect(timelineNode, scrollableNode, $mouseInside) {
  const [$boundingRect, resetBoundingRect] = createAtom(timelineNode.getBoundingClientRect());
  const onResize = () => {
    $boundingRect.set(timelineNode.getBoundingClientRect());
  };
  const onScroll = (event2) => {
    if (event2.target !== scrollableNode) {
      $boundingRect.set(timelineNode.getBoundingClientRect());
    }
  };
  const unsubscribe = $mouseInside.subscribe((isMouseInside) => {
    if (isMouseInside) {
      onResize();
      window.addEventListener("resize", onResize);
      window.addEventListener("scroll", onScroll, true);
    } else {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("scroll", onScroll, true);
    }
  });
  const reset = () => {
    unsubscribe();
    window.removeEventListener("resize", onResize);
    window.removeEventListener("scroll", onScroll, true);
    resetBoundingRect();
  };
  return [$boundingRect, reset];
}
function initContainerScrollTop(scrollableNode) {
  const [$containerScrollTop, resetContainerScrollTop] = createAtom(scrollableNode.scrollTop);
  const onScroll = () => {
    const { scrollTop } = scrollableNode;
    if ($containerScrollTop.get() === scrollTop) {
      return;
    }
    $containerScrollTop.set(scrollTop);
  };
  window.addEventListener("scroll", onScroll, true);
  const reset = () => {
    window.removeEventListener("scroll", onScroll, true);
    resetContainerScrollTop();
  };
  return [$containerScrollTop, reset];
}
function initDragHandler(scrollableNode, $timelineSize, $mouseCoords, $mouseInside, $timeState, $activeEventVisible, setTimeState) {
  const [$dragging, resetDragging] = createAtom(false);
  let draggingOffTimeout = null;
  const dragMove = () => {
    if (draggingOffTimeout) {
      clearTimeout(draggingOffTimeout);
      draggingOffTimeout = null;
    }
    if (!$dragging.get()) {
      $dragging.set(true);
    }
  };
  const dragStop = () => {
    if (draggingOffTimeout) {
      return;
    }
    draggingOffTimeout = setTimeout(() => {
      $dragging.set(false);
      draggingOffTimeout = null;
    }, 50);
  };
  let lastLeft = null;
  let lastTop = null;
  const onMouseMove = (event2) => {
    const left = event2.clientX;
    const top = event2.clientY;
    if (!lastLeft) {
      lastLeft = left;
    }
    if (!lastTop) {
      lastTop = top;
    }
    const leftDiff = left - lastLeft;
    const topDiff = top - lastTop;
    if (leftDiff === 0 && topDiff === 0) {
      return;
    }
    dragMove();
    event2.preventDefault();
    const { start, scale } = $timeState.get();
    const timeDiff = leftDiff * scale;
    scrollableNode.scrollTop = scrollableNode.scrollTop - topDiff;
    lastLeft = left;
    lastTop = top;
    setTimeState({
      scale,
      start: start - timeDiff
    });
  };
  const onMouseUp = () => {
    lastLeft = null;
    lastTop = null;
    dragStop();
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("mousemove", onMouseMove);
  };
  const onMouseDown = (event2) => {
    const activeEventVisible = $activeEventVisible.get();
    const { headerHeight, sidebarWidth, width, activeEventPanelWidth } = $timelineSize.get();
    const { left, top } = $mouseCoords.get();
    if (left < sidebarWidth || top < headerHeight) {
      return;
    }
    if (activeEventVisible && left > width - activeEventPanelWidth) {
      return;
    }
    lastLeft = event2.clientX;
    lastTop = event2.clientY;
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
  };
  $mouseInside.subscribe((isMouseInside) => {
    if (isMouseInside) {
      document.addEventListener("mousedown", onMouseDown);
    } else {
      document.removeEventListener("mousedown", onMouseDown);
    }
  });
  const reset = () => {
    document.removeEventListener("mousedown", onMouseDown);
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("mousemove", onMouseMove);
    resetDragging();
  };
  return [$dragging, reset];
}
function initMouseCoords($mouseInside, $boundingRect) {
  const [$mouseCoords, resetMouseCoords] = createAtom({ left: 0, top: 0 });
  const onMouseMove = (event2) => {
    const { left, top } = $boundingRect.get();
    $mouseCoords.set({
      left: event2.clientX - left,
      top: event2.clientY - top
    });
  };
  const unsubscribe = $mouseInside.subscribe((isMouseInside) => {
    if (isMouseInside) {
      window.addEventListener("mousemove", onMouseMove);
    } else {
      window.removeEventListener("mousemove", onMouseMove);
    }
  });
  const reset = () => {
    unsubscribe();
    window.removeEventListener("mousemove", onMouseMove);
    resetMouseCoords();
  };
  return [$mouseCoords, reset];
}
function initMouseInside(timelineNode) {
  const [$mouseInside, resetMouseInside] = createAtom(false);
  const onMouseEnter = () => {
    $mouseInside.set(true);
  };
  const onMouseLeave = () => {
    $mouseInside.set(false);
  };
  timelineNode.addEventListener("mouseenter", onMouseEnter);
  timelineNode.addEventListener("mouseleave", onMouseLeave);
  const reset = () => {
    timelineNode.removeEventListener("mouseenter", onMouseEnter);
    timelineNode.removeEventListener("mouseleave", onMouseLeave);
    resetMouseInside();
  };
  return [$mouseInside, reset];
}
function initMouseTime($mouseInside, $mouseCoords, $timelineSize, $timeState) {
  const [$mouseTime, resetMouseTime] = createAtom(null);
  $mouseCoords.listen(({ left, top }) => {
    const { sidebarWidth, width, headerHeight, height } = $timelineSize.get();
    if (left < sidebarWidth || left > width || top < headerHeight || top > height) {
      $mouseTime.set(null);
    } else {
      const { scale, start } = $timeState.get();
      const time2 = Math.round(start + left * scale);
      $mouseTime.set(time2);
    }
  });
  $mouseInside.listen((isMouseInside) => {
    if (!isMouseInside) {
      $mouseTime.set(null);
    }
  });
  $timeState.listen(() => {
    $mouseTime.set(null);
  });
  return [$mouseTime, resetMouseTime];
}
function initScaleAnimation($timeState, $timelineSize, setTimeState) {
  const animationController = initAnimationController($timeState.get().scale, (newScale) => {
    if (newScale > MAX_SCALE) {
      newScale = MAX_SCALE;
    } else if (newScale < MIN_SCALE) {
      newScale = MIN_SCALE;
    }
    const timelineSize = $timelineSize.get();
    const containerOffset = timelineSize.sidebarWidth + timelineSize.dataWidth / 2;
    const currentTimeState = $timeState.get();
    const { scale: currentScale, start: currentStart } = currentTimeState;
    const newStart = Math.round(currentStart + containerOffset * currentScale - containerOffset * newScale);
    if (newScale === currentScale && newStart === currentStart) {
      return;
    }
    setTimeState({
      scale: newScale,
      start: newStart
    });
  });
  const unsubscribeTimeState = $timeState.subscribe((timeState) => {
    animationController.set(timeState.scale);
  });
  const animateScale = (factor) => {
    const currentTimeState = $timeState.get();
    const { scale: currentScale } = currentTimeState;
    let newScale = currentScale * factor;
    if (newScale > MAX_SCALE) {
      newScale = MAX_SCALE;
    } else if (newScale < MIN_SCALE) {
      newScale = MIN_SCALE;
    }
    animationController.move(newScale, Math.abs(currentScale - newScale));
  };
  const reset = () => {
    unsubscribeTimeState();
    animationController.reset();
  };
  return [animateScale, reset];
}
var SHIFT_TRESHOLD = 500;
function initScrollHandler(scrollableNode, $timeState, setTimeState) {
  const [$containerScrollLeft, resetContainerScrollLeft] = createAtom(scrollableNode.scrollLeft);
  const shiftToCenter = () => {
    const { offsetWidth, scrollWidth } = scrollableNode;
    const newScrollLeft = Math.round(scrollWidth / 2 - offsetWidth / 2);
    $containerScrollLeft.set(newScrollLeft);
    scrollableNode.scrollLeft = newScrollLeft;
  };
  const onScroll = () => {
    const { scrollLeft } = scrollableNode;
    const currentScrollLeft = $containerScrollLeft.get();
    if (currentScrollLeft === scrollLeft) {
      return;
    }
    const { scale, start } = $timeState.get();
    const diff = scrollLeft - currentScrollLeft;
    const newStart = start + diff * scale;
    setTimeState({
      scale,
      start: newStart
    });
    const { offsetWidth, scrollWidth } = scrollableNode;
    const right = scrollWidth - scrollLeft - offsetWidth;
    if (scrollLeft < SHIFT_TRESHOLD || right < SHIFT_TRESHOLD) {
      shiftToCenter();
      return;
    } else {
      $containerScrollLeft.set(scrollLeft);
    }
  };
  window.addEventListener("scroll", onScroll, true);
  const reset = () => {
    window.removeEventListener("scroll", onScroll, true);
    resetContainerScrollLeft();
  };
  return reset;
}
function getDefaultCenterTime(defaultViewRange) {
  if (!defaultViewRange) {
    return Date.now();
  }
  const [start, end] = defaultViewRange;
  return Math.round((end + start) / 2);
}
function getDefaultScale(dataWidth, defaultViewRange) {
  if (!defaultViewRange) {
    return DEFAULT_SCALE;
  }
  const [start, end] = defaultViewRange;
  const scale = (end - start) / dataWidth;
  if (scale > MAX_SCALE) {
    return MAX_SCALE;
  } else if (scale < MIN_SCALE) {
    return MIN_SCALE;
  }
  return scale;
}
function setState($timeState, newTimeState) {
  const { scale, start } = $timeState.get();
  const { scale: newScale, start: newStart } = newTimeState;
  if (start !== newStart || scale !== newScale) {
    $timeState.set({
      start: newStart,
      scale: newScale
    });
  }
}
function fitTimeStateToLimit($timelineSize, viewRangeLimit, timeState) {
  const [startLimit, endLimit] = viewRangeLimit;
  if (!startLimit && !endLimit) {
    return timeState;
  }
  const { sidebarWidth, dataWidth, width } = $timelineSize.get();
  const { start, scale } = timeState;
  if (!endLimit && startLimit) {
    const sidebarWidthTime = scale * sidebarWidth;
    if (start < startLimit - sidebarWidthTime) {
      return {
        start: startLimit - sidebarWidthTime,
        scale
      };
    }
  }
  if (!startLimit && endLimit) {
    const widthTime = scale * width;
    if (start > endLimit - widthTime) {
      return {
        start: endLimit - widthTime,
        scale
      };
    }
  }
  if (startLimit && endLimit) {
    const scaleLimit = (endLimit - startLimit) / dataWidth;
    if (scaleLimit <= scale) {
      return {
        scale: scaleLimit,
        start: startLimit - scaleLimit * sidebarWidth
      };
    }
    const sidebarWidthTime = scale * sidebarWidth;
    if (start < startLimit - sidebarWidthTime) {
      return {
        start: startLimit - sidebarWidthTime,
        scale
      };
    }
    const widthTime = scale * width;
    if (start > endLimit - widthTime) {
      return {
        start: endLimit - widthTime,
        scale
      };
    }
  }
  return timeState;
}
function initTimeState($timelineSize, $viewRangeLimit, defaultViewRange) {
  const centerTime = getDefaultCenterTime(defaultViewRange);
  const { dataWidth, sidebarWidth } = $timelineSize.get();
  const scale = getDefaultScale(dataWidth, defaultViewRange);
  const centerPosition = sidebarWidth + dataWidth / 2;
  const start = Math.round(centerTime - scale * centerPosition);
  const [$timeState, resetTimeState] = createAtom(
    fitTimeStateToLimit($timelineSize, $viewRangeLimit.get(), {
      scale,
      start
    })
  );
  const setTimeState = (timeState) => {
    setState($timeState, fitTimeStateToLimit($timelineSize, $viewRangeLimit.get(), timeState));
  };
  const unsubscribeViewRangeLimit = $viewRangeLimit.listen(
    (viewRangeLimit) => setState($timeState, fitTimeStateToLimit($timelineSize, viewRangeLimit, $timeState.get()))
  );
  const reset = () => {
    unsubscribeViewRangeLimit();
    resetTimeState();
  };
  return [$timeState, setTimeState, reset];
}
var SIDEBAR_MIN_WIDTH = 280;
var EVENTS_MODAL_MIN_WIDTH = 320;
function getSidebarWidth(width, settings) {
  if (!settings.showSidebar) {
    return 0;
  }
  if (settings.sidebarWidth === "auto") {
    return Math.max(Math.round(width * 0.2), SIDEBAR_MIN_WIDTH);
  }
  return settings.sidebarWidth;
}
function getActiveEventPanelWidth(width, settings) {
  if (settings.activeEventPanelWidth === "auto") {
    return Math.max(Math.round(width * 0.3), EVENTS_MODAL_MIN_WIDTH);
  }
  return settings.activeEventPanelWidth;
}
function getTimelineSize(timelineNode, settings) {
  const width = timelineNode.offsetWidth;
  const height = timelineNode.offsetHeight;
  const headerHeight = settings.headerHeight;
  const sidebarWidth = getSidebarWidth(width, settings);
  const sidebarHeight = height - headerHeight;
  const dataWidth = width - sidebarWidth;
  const dataHeight = sidebarHeight;
  const activeEventPanelWidth = getActiveEventPanelWidth(width, settings);
  return {
    width,
    height,
    sidebarWidth,
    sidebarHeight,
    dataWidth,
    dataHeight,
    headerHeight,
    activeEventPanelWidth
  };
}
function updateTimelineSize($timelineSize, timelineNode, settings) {
  const currentSize = $timelineSize.get();
  const newSize = getTimelineSize(timelineNode, settings);
  if (currentSize.width !== newSize.width || currentSize.height !== newSize.height || currentSize.sidebarWidth !== newSize.sidebarWidth || currentSize.headerHeight !== newSize.headerHeight) {
    $timelineSize.set(newSize);
  }
}
function initTimelineSize(timelineNode, scrollableNode, $settings) {
  const [$timelineSize, resetTimelineSize] = createAtom(getTimelineSize(timelineNode, $settings.get()));
  const onResize = () => {
    updateTimelineSize($timelineSize, timelineNode, $settings.get());
  };
  const onScroll = (event2) => {
    if (event2.target !== scrollableNode) {
      updateTimelineSize($timelineSize, timelineNode, $settings.get());
    }
  };
  const unsibscribeSettings = $settings.listen((settings) => updateTimelineSize($timelineSize, timelineNode, settings));
  window.addEventListener("resize", onResize);
  window.addEventListener("scroll", onScroll, true);
  const reset = () => {
    window.removeEventListener("resize", onResize);
    window.removeEventListener("scroll", onScroll, true);
    resetTimelineSize();
    unsibscribeSettings();
  };
  return [$timelineSize, reset];
}
var DEFAULT_VIEW_RANGE_LIMIT = [null, null];
function initViewRangeLimit(viewRangeLimit) {
  const [$viewRangeLimit, resetViewRangeLimit] = createAtom(viewRangeLimit || DEFAULT_VIEW_RANGE_LIMIT);
  const setViewRangeLimit = (newViewRangeLimit) => $viewRangeLimit.set(newViewRangeLimit || DEFAULT_VIEW_RANGE_LIMIT);
  return [$viewRangeLimit, setViewRangeLimit, resetViewRangeLimit];
}
function initViewRangeTime($timeState, $timelineSize, onChangeViewRange) {
  const $viewRangeTime = computed(
    [$timeState, $timelineSize],
    (timeState, timelineSize) => {
      const leftPx = timelineSize.sidebarWidth;
      const rightPx = leftPx + timelineSize.dataWidth;
      const leftTime = Math.round(timeState.start + leftPx * timeState.scale);
      const rightTime = Math.round(timeState.start + rightPx * timeState.scale);
      return [leftTime, rightTime];
    }
  );
  const [$viewRangeTimeDebounced, resetDebounce] = debouncedStore($viewRangeTime, 500);
  $viewRangeTimeDebounced.listen((range) => onChangeViewRange(range));
  const reset = () => {
    resetDebounce();
    $viewRangeTime.off();
  };
  return [$viewRangeTime, reset];
}
var MAX_DELTA = 40;
function initZoomHandler($mouseCoords, $timeState, $mouseInside, setTimeState) {
  let unsubscribe = null;
  const subscribe = () => onWheel($mouseCoords, (containerOffset, delta) => {
    if (delta > MAX_DELTA) {
      delta = MAX_DELTA;
    } else if (delta < -MAX_DELTA) {
      delta = -MAX_DELTA;
    }
    const currentTimeState = $timeState.get();
    const { scale: currentScale, start: currentStart } = currentTimeState;
    const newTimeState = updateTimeState(currentTimeState, delta, containerOffset);
    const { scale: newScale, start: newStart } = newTimeState;
    if (newScale === currentScale && newStart === currentStart) {
      return;
    }
    setTimeState(newTimeState);
  });
  const unsubscribeMouseInside = $mouseInside.subscribe((isMouseInside) => {
    if (isMouseInside) {
      if (!unsubscribe) {
        unsubscribe = subscribe();
      }
    } else {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = null;
      }
    }
  });
  const reset = () => {
    unsubscribeMouseInside();
    if (unsubscribe) {
      unsubscribe();
    }
  };
  return reset;
}
function initViewState(timelineNode, scrollableNode, defaultViewRange, $settings, viewRangeLimit, onChangeViewRange) {
  const [$activeEventVisible, resetActiveEventVisible] = createAtom(false);
  const [$timelineSize, resetTimelineSize] = initTimelineSize(timelineNode, scrollableNode, $settings);
  const [$mouseInside, resetMouseInside] = initMouseInside(timelineNode);
  const [$boundingRect, resetBoundingRect] = initBoundingRect(timelineNode, scrollableNode, $mouseInside);
  const [$mouseCoords, resetMouseCoords] = initMouseCoords($mouseInside, $boundingRect);
  const [$viewRangeLimit, setViewRangeLimit, resetViewRangeLimit] = initViewRangeLimit(viewRangeLimit);
  const [$timeState, setTimeState, resetTimeState] = initTimeState($timelineSize, $viewRangeLimit, defaultViewRange);
  const [animateScale, resetScaleAnimation] = initScaleAnimation($timeState, $timelineSize, setTimeState);
  const [$containerScrollTop, resetContainerScrollTop] = initContainerScrollTop(scrollableNode);
  const [$mouseTime, resetMouseTime] = initMouseTime($mouseInside, $mouseCoords, $timelineSize, $timeState);
  const [$viewRangeTime, resetViewRangeTime] = initViewRangeTime($timeState, $timelineSize, onChangeViewRange);
  const [$dragging, resetDragHandler] = initDragHandler(
    scrollableNode,
    $timelineSize,
    $mouseCoords,
    $mouseInside,
    $timeState,
    $activeEventVisible,
    setTimeState
  );
  const resetScrollHandler = initScrollHandler(scrollableNode, $timeState, setTimeState);
  const resetZoomHandler = initZoomHandler($mouseCoords, $timeState, $mouseInside, setTimeState);
  const viewState = {
    $timelineSize,
    $mouseInside,
    $boundingRect,
    $mouseCoords,
    $timeState,
    $containerScrollTop,
    $mouseTime,
    $viewRangeTime,
    $dragging,
    $activeEventVisible,
    setViewRangeLimit,
    animateScale
  };
  const reset = () => {
    resetZoomHandler();
    resetTimelineSize();
    resetMouseInside();
    resetBoundingRect();
    resetMouseCoords();
    resetTimeState();
    resetScrollHandler();
    resetContainerScrollTop();
    resetMouseTime();
    resetViewRangeTime();
    resetScaleAnimation();
    resetViewRangeLimit();
    resetDragHandler();
    resetActiveEventVisible();
  };
  return [viewState, reset];
}
function initStore(timelineNode, scrollableNode, containerNode, canvasNode, getRows, getEvents2, viewTimeZoneName, defaultViewRange, onChangeViewRange, defaultSettings, eventsLoadStepSize, viewRangeLimit) {
  const [$settings, setSettings, resetSettings] = initSettings(defaultSettings);
  const [$colors, setColorScheme, resetColors] = initColors(timelineNode);
  const [$currentTime, resetCurrentTime] = initCurrentTime();
  const [viewState, resetViewState] = initViewState(
    timelineNode,
    scrollableNode,
    defaultViewRange,
    $settings,
    viewRangeLimit,
    onChangeViewRange
  );
  const [$renderedEvents, resetRenderedEvents] = initRenderedEvents();
  const [$viewTimeZone, setViewTimeZone, resetViewTimeZone] = initViewTimeZone(viewState, viewTimeZoneName);
  const [gridState, resetGridState] = initGridState(viewState, $viewTimeZone);
  const [$rowsStore, reInitRows, resetRowsStore] = initRows(
    containerNode,
    scrollableNode,
    viewState,
    $settings,
    getRows
  );
  const [$eventsStore, reInitEvents, resetEventsStore] = initEvents(
    $rowsStore,
    viewState,
    getEvents2,
    eventsLoadStepSize
  );
  const [$rowsEvents, resetRowsEvents] = initRowsEvents(viewState, $rowsStore, $eventsStore);
  const [$hoveredRow, resetHoveredRow] = initHoveredRow(viewState, $rowsStore);
  const [$hoveredEvent, $activeEvent, resetHoveredEvent] = initHoveredEvent(
    viewState,
    $rowsStore,
    $hoveredRow,
    $rowsEvents,
    $settings
  );
  const resetRowsHeightController = initRowsHeightController($rowsStore, $rowsEvents, $settings);
  const resetCanvas = initCanvas(
    canvasNode,
    viewState,
    gridState,
    $rowsStore,
    $rowsEvents,
    $hoveredRow,
    $hoveredEvent,
    $colors,
    $settings,
    $renderedEvents,
    $activeEvent
  );
  const reset = () => {
    resetCurrentTime();
    resetCanvas();
    resetRowsStore();
    resetEventsStore();
    resetRowsEvents();
    resetRowsHeightController();
    resetHoveredRow();
    resetHoveredEvent();
    resetColors();
    resetViewState();
    resetGridState();
    resetViewTimeZone();
    resetSettings();
    resetRenderedEvents();
  };
  const timelineStore = {
    viewState,
    gridState,
    $rowsStore,
    $eventsStore,
    $currentTime,
    $colors,
    $rowsEvents,
    $hoveredRow,
    $hoveredEvent,
    $activeEvent,
    $viewTimeZone,
    $settings,
    $renderedEvents,
    reInitRows,
    reInitEvents,
    reset,
    setColorScheme,
    setViewTimeZone,
    setSettings
  };
  return timelineStore;
}
var timeline = "_timeline_ch0cm_1";
var themedark = "_themedark_ch0cm_32";
var dragging = "_dragging_ch0cm_56";
var container = "_container_ch0cm_60";
var scrollArea = "_scrollArea_ch0cm_66";
var canvas = "_canvas_ch0cm_75";
var styles = {
  timeline,
  themedark,
  dragging,
  container,
  scrollArea,
  canvas
};
function Timeline({
  className,
  getRows,
  getEvents: getEvents2,
  colorScheme,
  viewTimeZone,
  defaultViewRange,
  onChangeViewRange,
  canChangeCrossEventsStrategy,
  crossEventsStrategy: crossEventsStrategy2,
  sidebarWidth,
  activeEventPanelWidth,
  showCurrentTime,
  showMouseTime,
  showHoveredEventPopup,
  highlightHoveredEvent,
  showTimezoneInfo,
  showScaleController,
  showSidebar,
  headerHeight,
  dataViewPadding,
  rowPadding,
  eventLineHeight,
  eventLineMargin,
  eventBorderRadius,
  eventContentMinWidth,
  highlightHoveredRow,
  renderGridLines,
  eventsLoadStepSize,
  viewRangeLimit,
  renderEventContent,
  renderActiveEvent: renderActiveEvent2,
  renderEventPopupContent,
  renderSidebarRowContent
}) {
  const timelineRef = (0, import_react.useRef)(null);
  const scrollableRef = (0, import_react.useRef)(null);
  const containerRef = (0, import_react.useRef)(null);
  const canvasRef = (0, import_react.useRef)(null);
  const [timelineStore, setTimelineStore] = (0, import_react.useState)(null);
  const persistentOnChangeViewRange = usePersistentCallback(onChangeViewRange);
  (0, import_react.useEffect)(() => {
    const timelineNode = timelineRef.current;
    const containerNode = containerRef.current;
    const scrollableNode = scrollableRef.current;
    if (timelineNode && containerNode && scrollableNode) {
      scrollableNode.scrollLeft = Math.round(containerNode.offsetWidth / 2 - timelineNode.offsetWidth / 2);
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.reInitRows(getRows);
    }
  }, [getRows]);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.reInitEvents(getEvents2, eventsLoadStepSize || DEFAULT_EVENTS_LOAD_STEP_SIZE);
    }
  }, [getEvents2, eventsLoadStepSize]);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.setColorScheme(colorScheme || null);
    }
  }, [colorScheme]);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.setViewTimeZone(viewTimeZone || null);
    }
  }, [viewTimeZone]);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.viewState.setViewRangeLimit(viewRangeLimit || null);
    }
  }, [viewRangeLimit]);
  const timelineSettings = (0, import_react.useMemo)(
    () => ({
      canChangeCrossEventsStrategy,
      crossEventsStrategy: crossEventsStrategy2,
      sidebarWidth,
      activeEventPanelWidth,
      showCurrentTime,
      showMouseTime,
      showHoveredEventPopup,
      highlightHoveredEvent,
      showTimezoneInfo,
      showScaleController,
      showSidebar,
      headerHeight,
      dataViewPadding,
      rowPadding,
      eventLineHeight,
      eventLineMargin,
      eventBorderRadius,
      eventContentMinWidth,
      highlightHoveredRow,
      renderGridLines,
      renderEventContent,
      renderActiveEvent: renderActiveEvent2,
      renderEventPopupContent,
      renderSidebarRowContent
    }),
    [
      canChangeCrossEventsStrategy,
      crossEventsStrategy2,
      sidebarWidth,
      activeEventPanelWidth,
      showCurrentTime,
      showMouseTime,
      showHoveredEventPopup,
      highlightHoveredEvent,
      showTimezoneInfo,
      showScaleController,
      showSidebar,
      headerHeight,
      dataViewPadding,
      rowPadding,
      eventLineHeight,
      eventLineMargin,
      eventBorderRadius,
      eventContentMinWidth,
      highlightHoveredRow,
      renderGridLines,
      renderEventContent,
      renderActiveEvent2,
      renderEventPopupContent,
      renderSidebarRowContent
    ]
  );
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      timelineStore.setSettings(timelineSettings);
    }
  }, [timelineSettings]);
  (0, import_react.useEffect)(() => {
    const timelineNode = timelineRef.current;
    const containerNode = containerRef.current;
    const scrollableNode = scrollableRef.current;
    const canvasNode = canvasRef.current;
    if (timelineNode && containerNode && scrollableNode && canvasNode) {
      const store = initStore(
        timelineNode,
        scrollableNode,
        containerNode,
        canvasNode,
        getRows,
        getEvents2,
        viewTimeZone || null,
        defaultViewRange || null,
        persistentOnChangeViewRange,
        timelineSettings,
        eventsLoadStepSize || DEFAULT_EVENTS_LOAD_STEP_SIZE,
        viewRangeLimit || null
      );
      setTimelineStore(store);
      return () => {
        store.reset();
      };
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (timelineStore) {
      const { $dragging } = timelineStore.viewState;
      return $dragging.subscribe((dragging2) => {
        if (!timelineRef.current) {
          return;
        }
        if (dragging2) {
          timelineRef.current.classList.add(styles.dragging);
        } else {
          timelineRef.current.classList.remove(styles.dragging);
        }
      });
    }
  }, [timelineStore]);
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx(className, styles.timeline, styles[`theme${colorScheme}`]), ref: timelineRef, children: [
    (0, import_jsx_runtime.jsx)("canvas", { className: styles.canvas, ref: canvasRef }),
    timelineStore && (0, import_jsx_runtime.jsx)(EnhancedRenderedEvents, { timelineStore }),
    (0, import_jsx_runtime.jsx)("div", { className: styles.scrollArea, ref: scrollableRef, children: (0, import_jsx_runtime.jsx)("div", { className: styles.container, ref: containerRef, children: timelineStore && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(EnhancedHeader, { timelineStore }),
      (0, import_jsx_runtime.jsx)(EnhancedSidebar, { timelineStore })
    ] }) }) }),
    timelineStore && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(EnhancedCurrentTime, { timelineStore }),
      (0, import_jsx_runtime.jsx)(EnhancedMouseTime, { timelineStore }),
      (0, import_jsx_runtime.jsx)(EnhancedHoveredEvent, { timelineStore }),
      (0, import_jsx_runtime.jsx)(EnhancedActiveEvent, { timelineStore })
    ] })
  ] });
}
export {
  Timeline
};
//# sourceMappingURL=@av_timeline.js.map
